[{"path":"https://www.borch.dev/uploads/deepMatchR/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 deepMatchR authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Antibody Visualization","text":"Visualizing HLA antibody data essential : Monitoring patient sensitization Identifying unacceptable antigens transplant Tracking antibody trends time Analyzing eplet-level reactivity patterns article covers deepMatchR’s visualization tools Single Antigen Bead (SAB) Panel Reactive Antibody (PRA) assay results.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"loading-the-package","dir":"Articles","previous_headings":"","what":"Loading the Package","title":"Antibody Visualization","text":"","code":"library(deepMatchR) library(dplyr) library(ggplot2)"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"example-data","dir":"Articles","previous_headings":"","what":"Example Data","title":"Antibody Visualization","text":"deepMatchR includes simulated assay data demonstrations:","code":"data(\"deepMatchR_example\")  # Available datasets: # 1. Class I SAB # 2. Class II SAB # 3. PRA  head(deepMatchR_example[[1]], 5) #>   BeadID         SpecAbbr       Specificity NormalValue  RawData CountValue #> 1      1  -,-,-,-,-,-,-,-       -,-,-,-,-,-          NA    48.04         77 #> 2      2  -,-,-,-,-,-,-,-       -,-,-,-,-,-          NA 14068.42         78 #> 3      3 A1,-,-,-,-,-,-,- A*01:01,-,-,-,-,-        0.00    37.41         73 #> 4      4 A2,-,-,-,-,-,-,- A*02:01,-,-,-,-,-      153.63   215.17         60 #> 5      5 A2,-,-,-,-,-,-,- A*02:03,-,-,-,-,-      127.24   180.22         85"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"data-format-requirements","dir":"Articles","previous_headings":"Example Data","what":"Data Format Requirements","title":"Antibody Visualization","text":"downstream analysis, data must include columns:","code":""},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"sab-bar-plot","dir":"Articles","previous_headings":"Plotting Antibodies","what":"SAB Bar Plot","title":"Antibody Visualization","text":"plotAntibodies() function creates publication-quality visualizations:","code":"plotAntibodies(   result_file = deepMatchR_example[[1]],   type = \"SAB\",   bead_cutoffs = c(2000, 1000, 500, 250),   add_table = TRUE,   palette = \"spectral\" )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"highlighting-specific-antigens","dir":"Articles","previous_headings":"Plotting Antibodies","what":"Highlighting Specific Antigens","title":"Antibody Visualization","text":"Focus antigens interest using highlight_antigen:","code":"plotAntibodies(   result_file = deepMatchR_example[[1]],   type = \"SAB\",   bead_cutoffs = c(2000, 1000, 500),   add_table = TRUE,   palette = \"spectral\",   highlight_antigen = c(\"Bw4\", \"Bw6\") )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"pra-bar-plot","dir":"Articles","previous_headings":"Plotting Antibodies","what":"PRA Bar Plot","title":"Antibody Visualization","text":"","code":"plotAntibodies(   result_file = deepMatchR_example[[3]],   type = \"PRA\",   class = \"I\",   add_table = TRUE,   palette = \"spectral\" )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"time-series-trend-plot","dir":"Articles","previous_headings":"Plotting Antibodies","what":"Time-Series Trend Plot","title":"Antibody Visualization","text":"Track antibody levels multiple time points:","code":"# Simulate longitudinal data set.seed(123) sab_data_list <- list(   \"01/01/2023\" = deepMatchR_example[[1]],   \"02/01/2023\" = deepMatchR_example[[1]] %>%     mutate(NormalValue = NormalValue * runif(n(), 0.5, 0.8)),   \"03/01/2023\" = deepMatchR_example[[1]] %>%     mutate(NormalValue = NormalValue * runif(n(), 1, 3)) )  plotAntibodies(   result_file = sab_data_list,   type = \"SAB\",   plot_trend = TRUE,   highlight_threshold = 5000,   vline_dates = c(\"2023-02-15\") )"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"ploteplets-overview","dir":"Articles","previous_headings":"Eplet Visualization","what":"plotEplets() Overview","title":"Antibody Visualization","text":"plotEplets() function offers three visualization types:","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"treemap-view","dir":"Articles","previous_headings":"Eplet Visualization","what":"Treemap View","title":"Antibody Visualization","text":"Tile area represents importance (positive beads × positivity rate):","code":"plotEplets(   result_file = deepMatchR_example[[1]],   plot_type = \"treemap\",   cutoff = 2000,   evidence_level = c(\"A1\", \"A2\", \"B\"),   percPos_filter = 0.4,   palette = \"spectral\" )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"bar-plot","dir":"Articles","previous_headings":"Eplet Visualization","what":"Bar Plot","title":"Antibody Visualization","text":"Ranks eplets positivity rate specific threshold:","code":"plotEplets(   result_file = deepMatchR_example[[1]],   plot_type = \"bar\",   group_by = \"loci\",   cutoff = 2000,   evidence_level = c(\"A1\", \"A2\", \"B\"),   percPos_filter = 0.4,   top_eplets = 20,   palette = \"spectral\" )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"auc-bar-plot","dir":"Articles","previous_headings":"Eplet Visualization","what":"AUC Bar Plot","title":"Antibody Visualization","text":"Ranks eplets performance across multiple thresholds:","code":"plotEplets(   result_file = deepMatchR_example[[1]],   plot_type = \"AUC\",   percPos_filter = 0.4,   group_by = \"evidence_level\",   cut_min = 250,   cut_max = 10000,   cut_step = 250,   top_eplets = 20,   palette = \"spectral\" )"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"epletauc-function","dir":"Articles","previous_headings":"Eplet AUC Analysis","what":"epletAUC() Function","title":"Antibody Visualization","text":"Calculates Area Curve eplet reactivity across multiple MFI thresholds. provides robust measure single cutoff.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"visualize-reactivity-curves","dir":"Articles","previous_headings":"Eplet AUC Analysis","what":"Visualize Reactivity Curves","title":"Antibody Visualization","text":"","code":"epletAUC(   result_file = deepMatchR_example[[1]],   group_by = \"evidence\",   evidence_level = c(\"A1\", \"A2\", \"B\", \"D\"),   plot_results = TRUE,   cut_min = 250,   cut_max = 10000,   cut_step = 250,   palette = \"inferno\" )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"get-auc-values-as-data","dir":"Articles","previous_headings":"Eplet AUC Analysis","what":"Get AUC Values as Data","title":"Antibody Visualization","text":"","code":"auc_result <- epletAUC(   result_file = deepMatchR_example[[1]],   plot_results = FALSE,   cut_min = 250,   cut_max = 10000,   cut_step = 250 ) head(auc_result) #>     eplet      AUC total_count   loci  norm_AUC #>    <char>    <num>       <int> <char>     <num> #> 1:   82LR 7817.708          24   A; B 0.7817708 #> 2:    80I 7022.059          17   A; B 0.7022059 #> 3:   69AA 5641.667          15      B 0.5641667 #> 4:  163EW 6691.667          15   A; B 0.6691667 #> 5:    41T 9583.333          12      B 0.9583333 #> 6:  65QIA 4761.364          11      B 0.4761364"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"advanced-filtering","dir":"Articles","previous_headings":"Eplet AUC Analysis","what":"Advanced Filtering","title":"Antibody Visualization","text":"","code":"epletAUC(   result_file = deepMatchR_example[[1]],   label = FALSE,   plot_results = TRUE,   eplet_filter = 10,      # Minimum bead count   percPos_filter = 1.0    # Minimum positivity threshold )"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"color-palettes","dir":"Articles","previous_headings":"Customization Options","what":"Color Palettes","title":"Antibody Visualization","text":"Available palettes include: spectral - Rainbow diverging inferno - Yellow purple viridis - Green purple plasma - Yellow magenta","code":"# Using inferno palette plotEplets(   result_file = deepMatchR_example[[1]],   plot_type = \"bar\",   cutoff = 2000,   top_eplets = 15,   palette = \"inferno\" )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"table-options","dir":"Articles","previous_headings":"Customization Options","what":"Table Options","title":"Antibody Visualization","text":"Control summary table add_table:","code":"# Without table plotAntibodies(   result_file = deepMatchR_example[[1]],   type = \"SAB\",   add_table = FALSE )"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/antibody-visualization.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session Information","title":"Antibody Visualization","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1     dplyr_1.1.4       deepMatchR_0.99.0 BiocStyle_2.38.0  #>  #> loaded via a namespace (and not attached): #>  [1] ggfittext_0.10.3       gtable_0.3.6           dir.expiry_1.18.0      #>  [4] xfun_0.56              bslib_0.9.0            lattice_0.22-7         #>  [7] quadprog_1.5-8         vctrs_0.7.1            tools_4.5.2            #> [10] generics_0.1.4         stats4_4.5.2           parallel_4.5.2         #> [13] tibble_3.3.1           pkgconfig_2.0.3        Matrix_1.7-4           #> [16] data.table_1.18.0      RColorBrewer_1.1-3     S7_0.2.1               #> [19] desc_1.4.3             S4Vectors_0.48.0       readxl_1.4.5           #> [22] lifecycle_1.0.5        compiler_4.5.2         farver_2.1.2           #> [25] textshaping_1.0.4      Biostrings_2.78.0      Seqinfo_1.0.0          #> [28] htmltools_0.5.9        sass_0.4.10            yaml_2.3.12            #> [31] pillar_1.11.1          pkgdown_2.2.0          crayon_1.5.3           #> [34] jquerylib_0.1.4        cachem_1.1.0           basilisk_1.22.0        #> [37] tidyselect_1.2.1       rvest_1.0.5            digest_0.6.39          #> [40] stringi_1.8.7          bookdown_0.46          labeling_0.4.3         #> [43] fastmap_1.2.0          grid_4.5.2             treemapify_2.6.0       #> [46] cli_3.6.5              magrittr_2.0.4         patchwork_1.3.2        #> [49] withr_3.0.2            filelock_1.0.3         scales_1.4.0           #> [52] rmarkdown_2.30         pwalign_1.6.0          XVector_0.50.0         #> [55] httr_1.4.7             reticulate_1.44.1      cellranger_1.1.0       #> [58] ragg_1.5.0             png_0.1-8              memoise_2.0.1          #> [61] evaluate_1.0.5         knitr_1.51             IRanges_2.44.0         #> [64] immReferent_0.99.6     rlang_1.1.7            Rcpp_1.1.1             #> [67] glue_1.8.0             BiocManager_1.30.27    xml2_1.5.2             #> [70] directlabels_2025.6.24 BiocGenerics_0.56.0    svglite_2.2.2          #> [73] jsonlite_2.0.0         R6_2.6.1               systemfonts_1.3.1      #> [76] fs_1.6.6"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting Started with deepMatchR","text":"Human leukocyte antigen (HLA) molecules central innate adaptive immune responses. Characterizing HLA antibodies typing plays pivotal role bone marrow solid organ transplantation. deepMatchR provides collection tools use advanced statistical approaches deep learning better characterize HLA immunogenicity clinical research applications. Key capabilities include: Sequence-level mismatch quantification (amino acid eplet) Peptide-MHC binding prediction Visualization antibody reactivity data Integration standard HLA nomenclature information, visit deepMatchR GitHub repository.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"installation","dir":"Articles","previous_headings":"Introduction","what":"Installation","title":"Getting Started with deepMatchR","text":"","code":"# Install from Bioconductor (when available) if (!requireNamespace(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") BiocManager::install(\"deepMatchR\")  # Or install the development version from GitHub # remotes::install_github(\"BorchLab/deepMatchR\")"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"quick-start","dir":"Articles","previous_headings":"Introduction","what":"Quick Start","title":"Getting Started with deepMatchR","text":"","code":"library(deepMatchR) library(dplyr) library(ggplot2)"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"built-in-example-data","dir":"Articles","previous_headings":"Working with HLA Data","what":"Built-in Example Data","title":"Getting Started with deepMatchR","text":"deepMatchR includes simulated assay data learning testing: Class SAB - Single Antigen Bead assay results Class II SAB - Single Antigen Bead assay results PRA - Panel Reactive Antibody assay results","code":"data(\"deepMatchR_example\")"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"data-format-requirements","dir":"Articles","previous_headings":"Working with HLA Data > Built-in Example Data","what":"Data Format Requirements","title":"Getting Started with deepMatchR","text":"downstream analysis, data must include columns:","code":"# Class I SAB example head(deepMatchR_example[[1]], 3) #>   BeadID         SpecAbbr       Specificity NormalValue  RawData CountValue #> 1      1  -,-,-,-,-,-,-,-       -,-,-,-,-,-          NA    48.04         77 #> 2      2  -,-,-,-,-,-,-,-       -,-,-,-,-,-          NA 14068.42         78 #> 3      3 A1,-,-,-,-,-,-,- A*01:01,-,-,-,-,-           0    37.41         73  # Class II SAB example head(deepMatchR_example[[2]], 3) #>   BeadID          SpecAbbr                      Specificity  RawData #> 1      1   -,-,-,-,-,-,-,-          -,-,-,-,-,-,-,-,-,-,-,-    15.51 #> 2      2   -,-,-,-,-,-,-,-          -,-,-,-,-,-,-,-,-,-,-,- 13759.52 #> 3      3 DR1,-,-,-,-,-,-,- DRB1*01:01,-,-,-,-,-,-,-,-,-,-,-   131.86 #>   NormalValue CountValue #> 1          NA        128 #> 2          NA         56 #> 3       75.22        117  # PRA example head(deepMatchR_example[[3]], 3) #>     BeadID               SpecAbbr                         Specificity #> 98       1                                                            #> 99       2                                                            #> 100      3 A2,-,B46,-,Bw6,-,Cw1,- A*02:01,A*02:07,B*46:01,-,C*01:02,- #>     NormalValue RawData CountValue #> 98           NA   12.13        272 #> 99           NA 9209.35        277 #> 100       551.9  602.17        152"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"creating-hla-genotypes","dir":"Articles","previous_headings":"Working with HLA Data","what":"Creating HLA Genotypes","title":"Getting Started with deepMatchR","text":"hlaGeno() function creates standardized genotype objects used throughout package.","code":"# Define recipient and donor genotypes recipient <- data.frame(   A_1 = \"A*01:01\", A_2 = \"A*02:01\",   B_1 = \"B*07:02\", B_2 = \"B*08:01\",   DQA1_1 = \"DQA1*02:01\", DQA1_2 = \"DQA1*05:05\",   DQB1_1 = \"DQB1*02:02\", DQB1_2 = \"DQB1*03:01\" )  donor <- data.frame(   A_1 = \"A*03:01\", A_2 = \"A*24:02\",   B_1 = \"B*44:02\", B_2 = \"B*51:01\",   DQA1_1 = \"DQA1*05:05\", DQA1_2 = \"DQA1*01:02\",   DQB1_1 = \"DQB1*06:02\", DQB1_2 = \"DQB1*03:01\" )  # Create genotype objects rgeno <- hlaGeno(recipient) dgeno <- hlaGeno(donor)"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"retrieving-allele-sequences","dir":"Articles","previous_headings":"Sequence-Level Analysis","what":"Retrieving Allele Sequences","title":"Getting Started with deepMatchR","text":"getAlleleSequence() function retrieves protein sequences IMGT/HLA database.","code":"# Get the amino acid sequence for A*01:01 a0101_seq <- getAlleleSequence(\"A*01:01\") # View first 50 amino acids substr(a0101_seq, 1, 50) #> [1] \"MAVMAPRTLLLLLSGALALTQTWAGSHSMRYFFTSVSRPGRGEPRFIAVG\""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"quantifying-amino-acid-mismatches","dir":"Articles","previous_headings":"Sequence-Level Analysis","what":"Quantifying Amino Acid Mismatches","title":"Getting Started with deepMatchR","text":"quantifyMismatch() function compares two protein sequences counts differences. can optionally filter biophysical properties.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"basic-usage","dir":"Articles","previous_headings":"Sequence-Level Analysis > Quantifying Amino Acid Mismatches","what":"Basic Usage","title":"Getting Started with deepMatchR","text":"","code":"seq1 <- \"YFAMYGEKVAHTHVDTLYVRYHY\" seq2 <- \"YFDMYGEKVAHTHVDTLYVRFHY\"  # Count all mismatches quantifyMismatch(seq1, seq2) #> [1] 2"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"filtering-by-biophysical-properties","dir":"Articles","previous_headings":"Sequence-Level Analysis > Quantifying Amino Acid Mismatches","what":"Filtering by Biophysical Properties","title":"Getting Started with deepMatchR","text":"deepMatchR uses classification models: Charge: K/R/H = positive; D/E = negative; others = neutral Polarity: Nonpolar {,V,L,,P,M,F,W,G}; Polar {S,T,N,Q,Y,C,H,K,R,D,E}","code":"# Only charge-changing mismatches quantifyMismatch(seq1,                   seq2,                   filter_charge = TRUE) #> [1] 1  # Only polarity-changing mismatches quantifyMismatch(seq1,                   seq2,                   filter_polarity = TRUE) #> [1] 2  # Both charge AND polarity changing quantifyMismatch(seq1,                   seq2,                   filter_charge = TRUE,                   filter_polarity = TRUE) #> [1] 1"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"detailed-position-by-position-analysis","dir":"Articles","previous_headings":"Sequence-Level Analysis > Quantifying Amino Acid Mismatches","what":"Detailed Position-by-Position Analysis","title":"Getting Started with deepMatchR","text":"detail output includes: is_mismatch: Whether amino acids differ position charge_change / polarity_change: Whether property changed counted: Whether position counts toward final tally","code":"details <- quantifyMismatch(seq1,                              seq2,                              return = \"detail\") head(details) #>   alignment_position ref alt is_gap_ref is_gap_alt is_mismatch charge_ref #> 1                  1   Y   Y      FALSE      FALSE       FALSE        neu #> 2                  2   F   F      FALSE      FALSE       FALSE        neu #> 3                  3   A   D      FALSE      FALSE        TRUE        neu #> 4                  4   M   M      FALSE      FALSE       FALSE        neu #> 5                  5   Y   Y      FALSE      FALSE       FALSE        neu #> 6                  6   G   G      FALSE      FALSE       FALSE        neu #>   charge_alt charge_change polarity_ref polarity_alt polarity_change counted #> 1        neu         FALSE        polar        polar           FALSE   FALSE #> 2        neu         FALSE     nonpolar     nonpolar           FALSE   FALSE #> 3        neg          TRUE     nonpolar        polar            TRUE    TRUE #> 4        neu         FALSE     nonpolar     nonpolar           FALSE   FALSE #> 5        neu         FALSE        polar        polar           FALSE   FALSE #> 6        neu         FALSE     nonpolar     nonpolar           FALSE   FALSE"},{"path":[]},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"calculating-mismatch-load","dir":"Articles","previous_headings":"Donor-Recipient Matching","what":"Calculating Mismatch Load","title":"Getting Started with deepMatchR","text":"calculateMismatchLoad() function aggregates amino acid mismatches across HLA loci donor recipient.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"total-mismatch-load","dir":"Articles","previous_headings":"Donor-Recipient Matching > Calculating Mismatch Load","what":"Total Mismatch Load","title":"Getting Started with deepMatchR","text":"","code":"calculateMismatchLoad(rgeno,                        dgeno,                        parallel = FALSE) #> [1] 378"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"per-locus-breakdown","dir":"Articles","previous_headings":"Donor-Recipient Matching > Calculating Mismatch Load","what":"Per-Locus Breakdown","title":"Getting Started with deepMatchR","text":"","code":"per_locus <- calculateMismatchLoad(   rgeno, dgeno,   return = \"per_locus\",   parallel = FALSE ) per_locus #>   locus mismatch_load #> 1     A            96 #> 2     B           128 #> 3  DQA1            71 #> 4  DQB1            83"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"pairwise-allele-matrix","dir":"Articles","previous_headings":"Donor-Recipient Matching > Calculating Mismatch Load","what":"Pairwise Allele Matrix","title":"Getting Started with deepMatchR","text":"View mismatches recipient-donor allele pair specific locus:","code":"mB <- calculateMismatchLoad(   rgeno, dgeno,   return = \"pairwise\",   pairwise_locus = \"B\",   parallel = FALSE ) mB #>          donor #> recipient B*44:02 B*51:01 #>   B*07:02      37      33 #>   B*08:01      31      27"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"applying-filters","dir":"Articles","previous_headings":"Donor-Recipient Matching > Calculating Mismatch Load","what":"Applying Filters","title":"Getting Started with deepMatchR","text":"","code":"# Charge-changing mismatches only calculateMismatchLoad(rgeno,                        dgeno,                        filter_charge = TRUE,                        parallel = FALSE) #> [1] 140  # Polarity-changing mismatches only calculateMismatchLoad(rgeno,                        dgeno,                        filter_polarity = TRUE,                        parallel = FALSE) #> [1] 138  # Restrict to specific loci calculateMismatchLoad(rgeno,                        dgeno,                        loci = \"A\",                        parallel = FALSE) #> [1] 96"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"eplet-analysis","dir":"Articles","previous_headings":"","what":"Eplet Analysis","title":"Getting Started with deepMatchR","text":"Eplets short amino acid sequences form antibody-binding epitopes HLA molecules. key determinants HLA immunogenicity.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"quantifying-eplet-mismatches","dir":"Articles","previous_headings":"Eplet Analysis","what":"Quantifying Eplet Mismatches","title":"Getting Started with deepMatchR","text":"quantifyEpletMismatch() function calculates number non-shared eplets two alleles.","code":"# Basic eplet comparison (A1/A2 evidence level) quantifyEpletMismatch(\"A*01:01\",                        \"A*02:01\") #> [1] 13  # Filter by exposition level quantifyEpletMismatch(\"B*07:02\",                        \"B*44:02\",                        exposition_filter = \"High\") #> [1] 6  # Filter by reactivity confirmation quantifyEpletMismatch(\"C*07:01\",                        \"C*06:02\",                       evidence_level = NULL,                       reactivity_filter = \"Confirmed\") #> [1] 9"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"calculating-eplet-load","dir":"Articles","previous_headings":"Eplet Analysis","what":"Calculating Eplet Load","title":"Getting Started with deepMatchR","text":"calculateEpletLoad() function calculates total donor-specific eplets across loci.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"total-eplet-load","dir":"Articles","previous_headings":"Eplet Analysis > Calculating Eplet Load","what":"Total Eplet Load","title":"Getting Started with deepMatchR","text":"","code":"calculateEpletLoad(rgeno,                     dgeno) #> [1] 19"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"per-locus-summary","dir":"Articles","previous_headings":"Eplet Analysis > Calculating Eplet Load","what":"Per-Locus Summary","title":"Getting Started with deepMatchR","text":"","code":"per <- calculateEpletLoad(rgeno,                            dgeno,                            return = \"per_locus\") per #>   locus eplet_load #> 1     A          4 #> 2     B          6 #> 3  DQA1          1 #> 4  DQB1          8"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"pairwise-allele-matrix-1","dir":"Articles","previous_headings":"Eplet Analysis > Calculating Eplet Load","what":"Pairwise Allele Matrix","title":"Getting Started with deepMatchR","text":"","code":"mB <- calculateEpletLoad(   rgeno, dgeno,   return = \"pairwise\",   pairwise_locus = \"B\" ) mB #>          donor #> recipient B*44:02 B*51:01 #>   B*07:02       5       4 #>   B*08:01       4       3"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"applying-evidence-and-exposition-filters","dir":"Articles","previous_headings":"Eplet Analysis > Calculating Eplet Load","what":"Applying Evidence and Exposition Filters","title":"Getting Started with deepMatchR","text":"","code":"# High-exposition eplets only calculateEpletLoad(rgeno,                     dgeno,                     exposition_filter = \"High\") #> [1] 15  # Antibody-confirmed eplets only calculateEpletLoad(rgeno,                     dgeno,                     reactivity_filter = \"Confirmed\") #> [1] 19  # All evidence levels (no filter) calculateEpletLoad(rgeno,                     dgeno,                     evidence_level = NULL) #> [1] 79"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"mhcnuggets-integration","dir":"Articles","previous_headings":"Peptide Binding Prediction","what":"MHCnuggets Integration","title":"Getting Started with deepMatchR","text":"predictMHCnuggets() function provides R interface MHCnuggets deep learning model peptide-MHC binding prediction. Note: section requires Python dependencies skipped Windows due path length limitations TensorFlow/MHCnuggets installation.","code":"# Define peptides and allele peptides <- c(\"SIINFEKL\", \"LLFGYPVYV\") allele <- \"A*02:01\"  # Predict binding affinity (IC50) binding_results <- predictMHCnuggets(   peptides = peptides,   allele = allele,   mhc_class = \"I\",   rank_output = TRUE ) #> Predicting for 2 peptides #> Number of peptides skipped/total due to length 0 / 0 #> Building model #> Closest allele found HLA-A02:01 #> BA_to_HLAp model found, predicting with BA_to_HLAp model... #> Rank output selected, computing peptide IC50 ranks against human proteome peptides... #> Writing output files...  print(binding_results) #>     peptide    ic50 #> 1  SIINFEKL 5600.06 #> 2 LLFGYPVYV  535.92"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"calculating-peptide-binding-load","dir":"Articles","previous_headings":"Peptide Binding Prediction","what":"Calculating Peptide Binding Load","title":"Getting Started with deepMatchR","text":"calculatePeptideBindingLoad() function predicts transplant risk analyzing peptide-HLA binding recipient molecules donor-derived peptides. Workflow: Input processing - Standardizes recipient/donor allele formats Peptide derivation - Generates mismatched peptides sequence differences Binding prediction - Predicts IC50 using PWM, NetMHCpan, MHCflurry Risk calculation - Aggregates predictions risk scores","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"total-risk-score","dir":"Articles","previous_headings":"Peptide Binding Prediction > Calculating Peptide Binding Load","what":"Total Risk Score","title":"Getting Started with deepMatchR","text":"","code":"total_risk <- calculatePeptideBindingLoad(   recipient = rgeno,   donor = dgeno,   return = \"total\" ) print(total_risk) #> [1] 2366"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"per-allele-summary","dir":"Articles","previous_headings":"Peptide Binding Prediction > Calculating Peptide Binding Load","what":"Per-Allele Summary","title":"Getting Started with deepMatchR","text":"","code":"summary_load <- calculatePeptideBindingLoad(   recipient = rgeno,   donor = dgeno,   return = \"summary\" ) print(summary_load) #>   hla_allele n_peptides n_strong n_weak risk_contribution #> 1    A*01:01       1085        0    652            350.25 #> 2    A*02:01       1085        0    652            350.25 #> 3    B*07:02       1085        0    582            132.25 #> 4    B*08:01       1085        0    582            132.25 #> 5 DQA1*02:01       1085        0    652            350.25 #> 6 DQA1*05:05       1085        0    652            350.25 #> 7 DQB1*02:02       1085        0    652            350.25 #> 8 DQB1*03:01       1085        0    652            350.25"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"detailed-peptide-level-results","dir":"Articles","previous_headings":"Peptide Binding Prediction > Calculating Peptide Binding Load","what":"Detailed Peptide-Level Results","title":"Getting Started with deepMatchR","text":"","code":"detailed_load <- calculatePeptideBindingLoad(   recipient = rgeno,   donor = dgeno,   return = \"detail\" ) head(detailed_load) #>     peptide hla_allele predicted_ic50 binding_level contribution #> 1 FDSDAASQR    A*01:01          10000    non_binder          0.0 #> 2 DSDAASQRM    A*01:01           2500          weak          0.5 #> 3 SDAASQRME    A*01:01          10000    non_binder          0.0 #> 4 DAASQRMEP    A*01:01           2500          weak          0.5 #> 5 AASQRMEPR    A*01:01           2500          weak          0.5 #> 6 ASQRMEPRA    A*01:01           2500          weak          0.5"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"antibody-plots-with-plotantibodies","dir":"Articles","previous_headings":"Visualizing Antibody Data","what":"Antibody Plots with plotAntibodies()","title":"Getting Started with deepMatchR","text":"plotAntibodies() function creates publication-quality visualizations SAB PRA assay data.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"sab-bar-plot","dir":"Articles","previous_headings":"Visualizing Antibody Data > Antibody Plots with plotAntibodies()","what":"SAB Bar Plot","title":"Getting Started with deepMatchR","text":"","code":"plotAntibodies(   result_file = deepMatchR_example[[1]],   type = \"SAB\",   bead_cutoffs = c(2000, 1000, 500, 250),   add_table = TRUE,   palette = \"spectral\",   highlight_antigen = c(\"Bw4\") )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"pra-bar-plot","dir":"Articles","previous_headings":"Visualizing Antibody Data > Antibody Plots with plotAntibodies()","what":"PRA Bar Plot","title":"Getting Started with deepMatchR","text":"","code":"plotAntibodies(   result_file = deepMatchR_example[[3]],   type = \"PRA\",   class = \"I\",   add_table = TRUE,   palette = \"spectral\" )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"time-series-trend-plot","dir":"Articles","previous_headings":"Visualizing Antibody Data > Antibody Plots with plotAntibodies()","what":"Time-Series Trend Plot","title":"Getting Started with deepMatchR","text":"Track antibody levels multiple time points:","code":"# Simulate longitudinal data set.seed(123) sab_data_list <- list(   \"01/01/2023\" = deepMatchR_example[[1]],   \"02/01/2023\" = deepMatchR_example[[1]] %>%     mutate(NormalValue = NormalValue * runif(n(), 0.5, 0.8)),   \"03/01/2023\" = deepMatchR_example[[1]] %>%     mutate(NormalValue = NormalValue * runif(n(), 1, 3)) )  plotAntibodies(   result_file = sab_data_list,   type = \"SAB\",   plot_trend = TRUE,   highlight_threshold = 5000,   vline_dates = c(\"2023-02-15\") )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"eplet-reactivity-analysis-with-epletauc","dir":"Articles","previous_headings":"Visualizing Antibody Data","what":"Eplet Reactivity Analysis with epletAUC()","title":"Getting Started with deepMatchR","text":"epletAUC() function calculates Area Curve (AUC) eplet reactivity across multiple MFI thresholds. provides robust measure single cutoff.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"visualize-reactivity-curves","dir":"Articles","previous_headings":"Visualizing Antibody Data > Eplet Reactivity Analysis with epletAUC()","what":"Visualize Reactivity Curves","title":"Getting Started with deepMatchR","text":"","code":"epletAUC(   result_file = deepMatchR_example[[1]],   group_by = \"evidence\",   evidence_level = c(\"A1\", \"A2\", \"B\", \"D\"),   plot_results = TRUE,   cut_min = 250,   cut_max = 10000,   cut_step = 250,   palette = \"inferno\" )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"get-auc-values-as-data","dir":"Articles","previous_headings":"Visualizing Antibody Data > Eplet Reactivity Analysis with epletAUC()","what":"Get AUC Values as Data","title":"Getting Started with deepMatchR","text":"","code":"auc_result <- epletAUC(   result_file = deepMatchR_example[[1]],   plot_results = FALSE,   cut_min = 250,   cut_max = 10000,   cut_step = 250 ) head(auc_result) #>     eplet      AUC total_count   loci  norm_AUC #>    <char>    <num>       <int> <char>     <num> #> 1:   82LR 7817.708          24   A; B 0.7817708 #> 2:    80I 7022.059          17   A; B 0.7022059 #> 3:   69AA 5641.667          15      B 0.5641667 #> 4:  163EW 6691.667          15   A; B 0.6691667 #> 5:    41T 9583.333          12      B 0.9583333 #> 6:  65QIA 4761.364          11      B 0.4761364"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"advanced-filtering","dir":"Articles","previous_headings":"Visualizing Antibody Data > Eplet Reactivity Analysis with epletAUC()","what":"Advanced Filtering","title":"Getting Started with deepMatchR","text":"","code":"epletAUC(   result_file = deepMatchR_example[[1]],   label = FALSE,   plot_results = TRUE,   eplet_filter = 10,      # Minimum bead count   percPos_filter = 1.0    # Minimum positivity threshold )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"eplet-visualization-with-ploteplets","dir":"Articles","previous_headings":"Visualizing Antibody Data","what":"Eplet Visualization with plotEplets()","title":"Getting Started with deepMatchR","text":"plotEplets() function offers three visualization types eplet reactivity data.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"treemap-view","dir":"Articles","previous_headings":"Visualizing Antibody Data > Eplet Visualization with plotEplets()","what":"Treemap View","title":"Getting Started with deepMatchR","text":"Ideal overview eplet prominence. Tile area represents importance (positive beads x positivity rate):","code":"plotEplets(   result_file = deepMatchR_example[[1]],   plot_type = \"treemap\",   cutoff = 2000,   evidence_level = c(\"A1\", \"A2\", \"B\"),   percPos_filter = 0.4,   palette = \"spectral\" )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"bar-plot","dir":"Articles","previous_headings":"Visualizing Antibody Data > Eplet Visualization with plotEplets()","what":"Bar Plot","title":"Getting Started with deepMatchR","text":"Ranks eplets positivity rate specific threshold:","code":"plotEplets(   result_file = deepMatchR_example[[1]],   plot_type = \"bar\",   group_by = \"loci\",   cutoff = 2000,   evidence_level = c(\"A1\", \"A2\", \"B\"),   percPos_filter = 0.4,   top_eplets = 20,   palette = \"spectral\" )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"auc-bar-plot","dir":"Articles","previous_headings":"Visualizing Antibody Data > Eplet Visualization with plotEplets()","what":"AUC Bar Plot","title":"Getting Started with deepMatchR","text":"Ranks eplets performance across multiple thresholds:","code":"plotEplets(  result_file = deepMatchR_example[[1]],   plot_type = \"AUC\",   percPos_filter = 0.4,   group_by = \"evidence_level\",   cut_min = 250,   cut_max = 10000,   cut_step = 250,   top_eplets = 20,   palette = \"spectral\" )"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session Information","title":"Getting Started with deepMatchR","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_4.0.1     dplyr_1.1.4       deepMatchR_0.99.0 BiocStyle_2.38.0  #>  #> loaded via a namespace (and not attached): #>  [1] ggfittext_0.10.3       gtable_0.3.6           dir.expiry_1.18.0      #>  [4] xfun_0.56              bslib_0.9.0            lattice_0.22-7         #>  [7] quadprog_1.5-8         vctrs_0.7.1            tools_4.5.2            #> [10] generics_0.1.4         stats4_4.5.2           parallel_4.5.2         #> [13] tibble_3.3.1           pkgconfig_2.0.3        Matrix_1.7-4           #> [16] data.table_1.18.0      RColorBrewer_1.1-3     S7_0.2.1               #> [19] desc_1.4.3             S4Vectors_0.48.0       readxl_1.4.5           #> [22] lifecycle_1.0.5        compiler_4.5.2         farver_2.1.2           #> [25] textshaping_1.0.4      Biostrings_2.78.0      Seqinfo_1.0.0          #> [28] htmltools_0.5.9        sass_0.4.10            yaml_2.3.12            #> [31] pillar_1.11.1          pkgdown_2.2.0          crayon_1.5.3           #> [34] jquerylib_0.1.4        cachem_1.1.0           basilisk_1.22.0        #> [37] tidyselect_1.2.1       rvest_1.0.5            digest_0.6.39          #> [40] stringi_1.8.7          bookdown_0.46          labeling_0.4.3         #> [43] fastmap_1.2.0          grid_4.5.2             treemapify_2.6.0       #> [46] cli_3.6.5              magrittr_2.0.4         patchwork_1.3.2        #> [49] withr_3.0.2            filelock_1.0.3         scales_1.4.0           #> [52] rmarkdown_2.30         pwalign_1.6.0          XVector_0.50.0         #> [55] httr_1.4.7             reticulate_1.44.1      cellranger_1.1.0       #> [58] ragg_1.5.0             png_0.1-8              memoise_2.0.1          #> [61] evaluate_1.0.5         knitr_1.51             IRanges_2.44.0         #> [64] immReferent_0.99.6     rlang_1.1.7            Rcpp_1.1.1             #> [67] glue_1.8.0             BiocManager_1.30.27    xml2_1.5.2             #> [70] directlabels_2025.6.24 BiocGenerics_0.56.0    svglite_2.2.2          #> [73] jsonlite_2.0.0         R6_2.6.1               systemfonts_1.3.1      #> [76] fs_1.6.6"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/deepMatchR.html","id":"getting-help","dir":"Articles","previous_headings":"","what":"Getting Help","title":"Getting Started with deepMatchR","text":"questions, suggestions, encounter issues: GitHub Issues: github.com/BorchLab/deepMatchR/issues","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Eplet Analysis","text":"Eplets short amino acid sequences form antibody-binding epitopes HLA molecules. key determinants HLA immunogenicity play crucial role : - Predicting antibody development risk transplantation - Understanding patterns HLA sensitization - Guiding donor selection strategies article covers eplet-based analysis deepMatchR.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"loading-the-package","dir":"Articles","previous_headings":"","what":"Loading the Package","title":"Eplet Analysis","text":"","code":"library(deepMatchR) library(dplyr)"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"what-are-eplets","dir":"Articles","previous_headings":"Understanding Eplets","what":"What are Eplets?","title":"Eplet Analysis","text":"Eplets small configurations polymorphic amino acid residues molecular surface HLA molecules. originally defined HLAMatchmaker algorithm catalogued Eplet Registry. Key concepts: A1/A2: Antibody-verified eplets B: Theoretically predicted D: Deprecated High: Clearly exposed molecular surface Intermediate/Low: Less accessible Reactivity: Whether antibody binding confirmed","code":""},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"basic-comparison","dir":"Articles","previous_headings":"Quantifying Eplet Mismatches","what":"Basic Comparison","title":"Eplet Analysis","text":"quantifyEpletMismatch() function calculates non-shared eplets two alleles:","code":"# Basic eplet comparison (A1/A2 evidence level by default) quantifyEpletMismatch(\"A*01:01\", \"A*02:01\") #> [1] 13"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"filtering-by-evidence-level","dir":"Articles","previous_headings":"Quantifying Eplet Mismatches","what":"Filtering by Evidence Level","title":"Eplet Analysis","text":"","code":"# Only antibody-verified eplets (A1) quantifyEpletMismatch(\"A*01:01\", \"A*02:01\", evidence_level = \"A1\") #> [1] 8  # All evidence levels including theoretical quantifyEpletMismatch(\"A*01:01\", \"A*02:01\", evidence_level = NULL) #> [1] 59"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"filtering-by-exposition","dir":"Articles","previous_headings":"Quantifying Eplet Mismatches","what":"Filtering by Exposition","title":"Eplet Analysis","text":"","code":"# High-exposition eplets only quantifyEpletMismatch(\"B*07:02\", \"B*44:02\", exposition_filter = \"High\") #> [1] 6"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"filtering-by-reactivity","dir":"Articles","previous_headings":"Quantifying Eplet Mismatches","what":"Filtering by Reactivity","title":"Eplet Analysis","text":"","code":"# Confirmed reactive eplets only quantifyEpletMismatch(\"C*07:01\", \"C*06:02\",                       evidence_level = NULL,                       reactivity_filter = \"Confirmed\") #> [1] 9"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"calculating-eplet-load","dir":"Articles","previous_headings":"","what":"Calculating Eplet Load","title":"Eplet Analysis","text":"donor-recipient matching, use calculateEpletLoad() compute total donor-specific eplets across loci.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"creating-genotypes","dir":"Articles","previous_headings":"Calculating Eplet Load","what":"Creating Genotypes","title":"Eplet Analysis","text":"","code":"recipient <- data.frame(   A_1 = \"A*01:01\", A_2 = \"A*02:01\",   B_1 = \"B*07:02\", B_2 = \"B*08:01\",   DQB1_1 = \"DQB1*02:02\", DQB1_2 = \"DQB1*03:01\" )  donor <- data.frame(   A_1 = \"A*03:01\", A_2 = \"A*24:02\",   B_1 = \"B*44:02\", B_2 = \"B*51:01\",   DQB1_1 = \"DQB1*06:02\", DQB1_2 = \"DQB1*03:01\" )  rgeno <- hlaGeno(recipient) dgeno <- hlaGeno(donor)"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"total-eplet-load","dir":"Articles","previous_headings":"Calculating Eplet Load","what":"Total Eplet Load","title":"Eplet Analysis","text":"","code":"calculateEpletLoad(rgeno, dgeno) #> [1] 18"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"per-locus-summary","dir":"Articles","previous_headings":"Calculating Eplet Load","what":"Per-Locus Summary","title":"Eplet Analysis","text":"","code":"per_locus <- calculateEpletLoad(rgeno, dgeno, return = \"per_locus\") per_locus #>   locus eplet_load #> 1     A          4 #> 2     B          6 #> 3  DQB1          8"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"pairwise-allele-matrix","dir":"Articles","previous_headings":"Calculating Eplet Load","what":"Pairwise Allele Matrix","title":"Eplet Analysis","text":"","code":"mB <- calculateEpletLoad(   rgeno, dgeno,   return = \"pairwise\",   pairwise_locus = \"B\" ) mB #>          donor #> recipient B*44:02 B*51:01 #>   B*07:02       5       4 #>   B*08:01       4       3"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"applying-filters","dir":"Articles","previous_headings":"Calculating Eplet Load","what":"Applying Filters","title":"Eplet Analysis","text":"","code":"# High-exposition eplets only calculateEpletLoad(rgeno, dgeno, exposition_filter = \"High\") #> [1] 14  # Antibody-confirmed eplets only calculateEpletLoad(rgeno, dgeno, reactivity_filter = \"Confirmed\") #> [1] 18  # All evidence levels (no filter) calculateEpletLoad(rgeno, dgeno, evidence_level = NULL) #> [1] 77"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"eplet-load-and-dsa-risk","dir":"Articles","previous_headings":"Clinical Interpretation","what":"Eplet Load and DSA Risk","title":"Eplet Analysis","text":"Higher eplet mismatch loads generally associated increased risk donor-specific antibody (DSA) development. However, interpretation consider: Evidence quality: A1/A2 eplets stronger clinical validation Surface exposition: High-exposition eplets accessible antibodies Previous sensitization: Patient’s existing antibody profile Immunosuppression: Treatment protocol intensity","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"recommended-thresholds","dir":"Articles","previous_headings":"Clinical Interpretation","what":"Recommended Thresholds","title":"Eplet Analysis","text":"specific thresholds vary center organ type, general guidelines suggest: Note: general guidelines. Always consult institution’s protocols.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/eplet-analysis.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session Information","title":"Eplet Analysis","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] dplyr_1.1.4       deepMatchR_0.99.0 BiocStyle_2.38.0  #>  #> loaded via a namespace (and not attached): #>  [1] sass_0.4.10         generics_0.1.4      xml2_1.5.2          #>  [4] lattice_0.22-7      immReferent_0.99.6  digest_0.6.39       #>  [7] magrittr_2.0.4      evaluate_1.0.5      grid_4.5.2          #> [10] RColorBrewer_1.1-3  bookdown_0.46       fastmap_1.2.0       #> [13] cellranger_1.1.0    jsonlite_2.0.0      Matrix_1.7-4        #> [16] BiocManager_1.30.27 rvest_1.0.5         httr_1.4.7          #> [19] scales_1.4.0        Biostrings_2.78.0   textshaping_1.0.4   #> [22] jquerylib_0.1.4     cli_3.6.5           rlang_1.1.7         #> [25] crayon_1.5.3        XVector_0.50.0      cachem_1.1.0        #> [28] yaml_2.3.12         tools_4.5.2         dir.expiry_1.18.0   #> [31] parallel_4.5.2      memoise_2.0.1       ggplot2_4.0.1       #> [34] filelock_1.0.3      basilisk_1.22.0     BiocGenerics_0.56.0 #> [37] reticulate_1.44.1   vctrs_0.7.1         R6_2.6.1            #> [40] png_0.1-8           stats4_4.5.2        lifecycle_1.0.5     #> [43] pwalign_1.6.0       Seqinfo_1.0.0       IRanges_2.44.0      #> [46] S4Vectors_0.48.0    fs_1.6.6            ragg_1.5.0          #> [49] pkgconfig_2.0.3     desc_1.4.3          pkgdown_2.2.0       #> [52] pillar_1.11.1       bslib_0.9.0         gtable_0.3.6        #> [55] data.table_1.18.0   glue_1.8.0          Rcpp_1.1.1          #> [58] systemfonts_1.3.1   xfun_0.56           tibble_3.3.1        #> [61] tidyselect_1.2.1    knitr_1.51          farver_2.1.2        #> [64] patchwork_1.3.2     htmltools_0.5.9     rmarkdown_2.30      #> [67] compiler_4.5.2      S7_0.2.1            readxl_1.4.5"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Peptide Binding Prediction","text":"Peptide-MHC binding prediction central understanding T cell-mediated immunity. context transplantation, predicting recipient HLA molecules might present donor-derived peptides helps assess immunological risk. article covers: Using MHCnuggets peptide binding prediction Calculating peptide binding load donor-recipient pairs Interpreting binding predictions","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"loading-the-package","dir":"Articles","previous_headings":"","what":"Loading the Package","title":"Peptide Binding Prediction","text":"","code":"library(deepMatchR) library(dplyr)"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"peptide-mhc-binding","dir":"Articles","previous_headings":"Background","what":"Peptide-MHC Binding","title":"Peptide Binding Prediction","text":"MHC molecules present peptides T cells. binding affinity peptide MHC molecule determines: Presentation likelihood: Strong binders likely presented T cell activation potential: Better presentation leads stronger T cell responses Immunogenicity: Peptides bind well differ self immunogenic","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"binding-thresholds","dir":"Articles","previous_headings":"Background","what":"Binding Thresholds","title":"Peptide Binding Prediction","text":"Binding affinity typically measured IC50 (half-maximal inhibitory concentration):","code":""},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"overview","dir":"Articles","previous_headings":"MHCnuggets Prediction","what":"Overview","title":"Peptide Binding Prediction","text":"predictMHCnuggets() provides R interface MHCnuggets, deep learning model peptide-MHC binding prediction. Note: MHCnuggets requires Python dependencies via basilisk. functionality available Windows due path length limitations.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"basic-usage","dir":"Articles","previous_headings":"MHCnuggets Prediction","what":"Basic Usage","title":"Peptide Binding Prediction","text":"","code":"# Define peptides and allele peptides <- c(\"SIINFEKL\", \"LLFGYPVYV\", \"GILGFVFTL\") allele <- \"A*02:01\"  # Predict binding affinity binding_results <- predictMHCnuggets(   peptides = peptides,   allele = allele,   mhc_class = \"I\" ) #> Predicting for 3 peptides #> Number of peptides skipped/total due to length 0 / 0 #> Building model #> Closest allele found HLA-A02:01 #> BA_to_HLAp model found, predicting with BA_to_HLAp model... #> Writing output files...  print(binding_results) #>     peptide    ic50 #> 1  SIINFEKL 5600.06 #> 2 LLFGYPVYV  535.92 #> 3 GILGFVFTL  589.25"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"interpretation","dir":"Articles","previous_headings":"MHCnuggets Prediction","what":"Interpretation","title":"Peptide Binding Prediction","text":"output includes: peptide: Input peptide sequence allele: HLA allele tested ic50: Predicted binding affinity nM rank: Percentile rank (rank_output = TRUE)","code":""},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"concept","dir":"Articles","previous_headings":"Peptide Binding Load","what":"Concept","title":"Peptide Binding Prediction","text":"calculatePeptideBindingLoad() function estimates transplant risk : Identifying mismatched peptides donor sequences Predicting binding recipient HLA molecules Aggregating predictions risk score","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"creating-genotypes","dir":"Articles","previous_headings":"Peptide Binding Load","what":"Creating Genotypes","title":"Peptide Binding Prediction","text":"","code":"recipient <- data.frame(   A_1 = \"A*02:01\", A_2 = \"A*03:01\",   B_1 = \"B*07:02\", B_2 = \"B*08:01\" )  donor <- data.frame(   A_1 = \"A*01:01\", A_2 = \"A*24:02\",   B_1 = \"B*44:02\", B_2 = \"B*51:01\" )  rgeno <- hlaGeno(recipient) dgeno <- hlaGeno(donor)"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"total-risk-score","dir":"Articles","previous_headings":"Peptide Binding Load","what":"Total Risk Score","title":"Peptide Binding Prediction","text":"","code":"total_risk <- calculatePeptideBindingLoad(   recipient = rgeno,   donor = dgeno,   return = \"total\" ) print(total_risk) #> [1] 507.75"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"per-allele-summary","dir":"Articles","previous_headings":"Peptide Binding Load","what":"Per-Allele Summary","title":"Peptide Binding Prediction","text":"","code":"summary_load <- calculatePeptideBindingLoad(   recipient = rgeno,   donor = dgeno,   return = \"summary\" ) print(summary_load) #>   hla_allele n_peptides n_strong n_weak risk_contribution #> 1    A*02:01        601        0    346           187.750 #> 2    A*03:01        601        0    346           187.750 #> 3    B*07:02        601        0    293            66.125 #> 4    B*08:01        601        0    293            66.125"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"detailed-peptide-results","dir":"Articles","previous_headings":"Peptide Binding Load","what":"Detailed Peptide Results","title":"Peptide Binding Prediction","text":"","code":"detailed_load <- calculatePeptideBindingLoad(   recipient = rgeno,   donor = dgeno,   return = \"detail\" ) head(detailed_load) #>     peptide hla_allele predicted_ic50 binding_level contribution #> 1 AVMAPRTLL    A*02:01            625          weak        0.875 #> 2 VMAPRTLLL    A*02:01            625          weak        0.875 #> 3 MAPRTLLLL    A*02:01            625          weak        0.875 #> 4 APRTLLLLL    A*02:01           2500          weak        0.500 #> 5 PRTLLLLLS    A*02:01          10000    non_binder        0.000 #> 6 RTLLLLLSG    A*02:01           2500          weak        0.500"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"available-backends","dir":"Articles","previous_headings":"Backends","what":"Available Backends","title":"Peptide Binding Prediction","text":"calculatePeptideBindingLoad() supports multiple prediction backends:","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"using-pwm-default","dir":"Articles","previous_headings":"Backends","what":"Using PWM (Default)","title":"Peptide Binding Prediction","text":"PWM backend uses pre-computed position-specific scoring matrices based HLA supertypes:","code":"result_pwm <- calculatePeptideBindingLoad(   recipient = rgeno,   donor = dgeno,   backend = \"pwm\",   return = \"summary\" ) print(result_pwm) #>   hla_allele n_peptides n_strong n_weak risk_contribution #> 1    A*02:01        601        0    346           187.750 #> 2    A*03:01        601        0    346           187.750 #> 3    B*07:02        601        0    293            66.125 #> 4    B*08:01        601        0    293            66.125"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"customizing-thresholds","dir":"Articles","previous_headings":"Backends","what":"Customizing Thresholds","title":"Peptide Binding Prediction","text":"","code":"# Adjust binding thresholds result_custom <- calculatePeptideBindingLoad(   recipient = rgeno,   donor = dgeno,   binding_threshold = 100,   # Strong binder threshold   weak_threshold = 1000,     # Weak binder threshold   return = \"summary\" ) print(result_custom) #>   hla_allele n_peptides n_strong n_weak risk_contribution #> 1    A*02:01        601        0     78            29.250 #> 2    A*03:01        601        0     78            29.250 #> 3    B*07:02        601        0      3             1.125 #> 4    B*08:01        601        0      3             1.125"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"transplant-risk-assessment","dir":"Articles","previous_headings":"Clinical Applications","what":"Transplant Risk Assessment","title":"Peptide Binding Prediction","text":"Peptide binding load can complement eplet-based analysis: Eplet load: Predicts antibody-mediated rejection risk Peptide binding load: Predicts T cell-mediated rejection risk","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"integration-with-other-metrics","dir":"Articles","previous_headings":"Clinical Applications","what":"Integration with Other Metrics","title":"Peptide Binding Prediction","text":"Consider combining peptide binding predictions : HLA mismatch count Eplet mismatch load Pre-existing antibody profiles Clinical risk factors","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/peptide-binding.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session Information","title":"Peptide Binding Prediction","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] dplyr_1.1.4       deepMatchR_0.99.0 BiocStyle_2.38.0  #>  #> loaded via a namespace (and not attached): #>  [1] sass_0.4.10         generics_0.1.4      xml2_1.5.2          #>  [4] lattice_0.22-7      immReferent_0.99.6  digest_0.6.39       #>  [7] magrittr_2.0.4      evaluate_1.0.5      grid_4.5.2          #> [10] RColorBrewer_1.1-3  bookdown_0.46       fastmap_1.2.0       #> [13] cellranger_1.1.0    jsonlite_2.0.0      Matrix_1.7-4        #> [16] BiocManager_1.30.27 rvest_1.0.5         httr_1.4.7          #> [19] scales_1.4.0        Biostrings_2.78.0   textshaping_1.0.4   #> [22] jquerylib_0.1.4     cli_3.6.5           rlang_1.1.7         #> [25] crayon_1.5.3        XVector_0.50.0      cachem_1.1.0        #> [28] yaml_2.3.12         tools_4.5.2         dir.expiry_1.18.0   #> [31] parallel_4.5.2      memoise_2.0.1       ggplot2_4.0.1       #> [34] filelock_1.0.3      basilisk_1.22.0     BiocGenerics_0.56.0 #> [37] reticulate_1.44.1   vctrs_0.7.1         R6_2.6.1            #> [40] png_0.1-8           stats4_4.5.2        lifecycle_1.0.5     #> [43] pwalign_1.6.0       Seqinfo_1.0.0       IRanges_2.44.0      #> [46] S4Vectors_0.48.0    fs_1.6.6            ragg_1.5.0          #> [49] pkgconfig_2.0.3     desc_1.4.3          pkgdown_2.2.0       #> [52] pillar_1.11.1       bslib_0.9.0         gtable_0.3.6        #> [55] data.table_1.18.0   glue_1.8.0          Rcpp_1.1.1          #> [58] systemfonts_1.3.1   xfun_0.56           tibble_3.3.1        #> [61] tidyselect_1.2.1    knitr_1.51          farver_2.1.2        #> [64] patchwork_1.3.2     htmltools_0.5.9     rmarkdown_2.30      #> [67] compiler_4.5.2      S7_0.2.1            readxl_1.4.5"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Sequence & Mismatch Analysis","text":"article covers sequence-level HLA analysis deepMatchR, including: Retrieving allele sequences IMGT/HLA Quantifying amino acid mismatches sequences Calculating mismatch load donor-recipient pairs tools provide foundation understanding immunogenicity molecular level.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"loading-the-package","dir":"Articles","previous_headings":"","what":"Loading the Package","title":"Sequence & Mismatch Analysis","text":"","code":"library(deepMatchR) library(dplyr)"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"basic-usage","dir":"Articles","previous_headings":"Retrieving HLA Sequences","what":"Basic Usage","title":"Sequence & Mismatch Analysis","text":"getAlleleSequence() function retrieves protein sequences IMGT/HLA database.","code":"# Get the amino acid sequence for A*01:01 a0101_seq <- getAlleleSequence(\"A*01:01\") # View first 60 amino acids substr(a0101_seq, 1, 60) #> [1] \"MAVMAPRTLLLLLSGALALTQTWAGSHSMRYFFTSVSRPGRGEPRFIAVGYVDDTQFVRF\"  # Full sequence length nchar(a0101_seq) #> [1] 365"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"batch-retrieval","dir":"Articles","previous_headings":"Retrieving HLA Sequences","what":"Batch Retrieval","title":"Sequence & Mismatch Analysis","text":"multiple alleles, use batchGetSequences() efficient parallel retrieval:","code":"alleles <- c(\"A*01:01\", \"A*02:01\", \"B*07:02\") sequences <- batchGetSequences(alleles) # View sequence lengths sapply(sequences, nchar) #> A*01:01 A*02:01 B*07:02  #>     365     365     362"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"basic-mismatch-counting","dir":"Articles","previous_headings":"Quantifying Amino Acid Mismatches","what":"Basic Mismatch Counting","title":"Sequence & Mismatch Analysis","text":"quantifyMismatch() function compares two protein sequences counts differences:","code":"seq1 <- \"YFAMYGEKVAHTHVDTLYVRYHY\" seq2 <- \"YFDMYGEKVAHTHVDTLYVRFHY\"  # Count all mismatches quantifyMismatch(seq1, seq2) #> [1] 2"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"biophysical-property-filters","dir":"Articles","previous_headings":"Quantifying Amino Acid Mismatches","what":"Biophysical Property Filters","title":"Sequence & Mismatch Analysis","text":"can filter mismatches biophysical properties focus functionally significant changes:","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"charge-classification","dir":"Articles","previous_headings":"Quantifying Amino Acid Mismatches > Biophysical Property Filters","what":"Charge Classification","title":"Sequence & Mismatch Analysis","text":"Positive: K, R, H Negative: D, E Neutral: others","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"polarity-classification","dir":"Articles","previous_headings":"Quantifying Amino Acid Mismatches > Biophysical Property Filters","what":"Polarity Classification","title":"Sequence & Mismatch Analysis","text":"Nonpolar: , V, L, , P, M, F, W, G Polar: S, T, N, Q, Y, C, H, K, R, D, E","code":"# Only charge-changing mismatches quantifyMismatch(seq1, seq2, filter_charge = TRUE) #> [1] 1  # Only polarity-changing mismatches quantifyMismatch(seq1, seq2, filter_polarity = TRUE) #> [1] 2  # Both charge AND polarity changing quantifyMismatch(seq1, seq2, filter_charge = TRUE, filter_polarity = TRUE) #> [1] 1"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"detailed-position-analysis","dir":"Articles","previous_headings":"Quantifying Amino Acid Mismatches","what":"Detailed Position Analysis","title":"Sequence & Mismatch Analysis","text":"Get position--position breakdown: detail output includes:","code":"details <- quantifyMismatch(seq1, seq2, return = \"detail\") head(details) #>   alignment_position ref alt is_gap_ref is_gap_alt is_mismatch charge_ref #> 1                  1   Y   Y      FALSE      FALSE       FALSE        neu #> 2                  2   F   F      FALSE      FALSE       FALSE        neu #> 3                  3   A   D      FALSE      FALSE        TRUE        neu #> 4                  4   M   M      FALSE      FALSE       FALSE        neu #> 5                  5   Y   Y      FALSE      FALSE       FALSE        neu #> 6                  6   G   G      FALSE      FALSE       FALSE        neu #>   charge_alt charge_change polarity_ref polarity_alt polarity_change counted #> 1        neu         FALSE        polar        polar           FALSE   FALSE #> 2        neu         FALSE     nonpolar     nonpolar           FALSE   FALSE #> 3        neg          TRUE     nonpolar        polar            TRUE    TRUE #> 4        neu         FALSE     nonpolar     nonpolar           FALSE   FALSE #> 5        neu         FALSE        polar        polar           FALSE   FALSE #> 6        neu         FALSE     nonpolar     nonpolar           FALSE   FALSE"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"handling-unknown-residues","dir":"Articles","previous_headings":"Quantifying Amino Acid Mismatches","what":"Handling Unknown Residues","title":"Sequence & Mismatch Analysis","text":"na_action parameter controls unknown residues (X, -, etc.) handled:","code":"seq_with_unknown <- \"YFAMYGEKVAHTHVDTLYVRXHY\"  # Exclude unknown positions (default) quantifyMismatch(seq1, seq_with_unknown, na_action = \"exclude\") #> [1] 1  # Count unknowns as mismatches quantifyMismatch(seq1, seq_with_unknown, na_action = \"count\") #> [1] 1"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"creating-hla-genotypes","dir":"Articles","previous_headings":"Donor-Recipient Mismatch Load","what":"Creating HLA Genotypes","title":"Sequence & Mismatch Analysis","text":"First, create genotype objects using hlaGeno():","code":"recipient <- data.frame(   A_1 = \"A*01:01\", A_2 = \"A*02:01\",   B_1 = \"B*07:02\", B_2 = \"B*08:01\",   DRB1_1 = \"DRB1*03:01\", DRB1_2 = \"DRB1*04:01\" )  donor <- data.frame(   A_1 = \"A*03:01\", A_2 = \"A*24:02\",   B_1 = \"B*44:02\", B_2 = \"B*51:01\",   DRB1_1 = \"DRB1*07:01\", DRB1_2 = \"DRB1*11:01\" )  rgeno <- hlaGeno(recipient) dgeno <- hlaGeno(donor)"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"calculating-total-mismatch-load","dir":"Articles","previous_headings":"Donor-Recipient Mismatch Load","what":"Calculating Total Mismatch Load","title":"Sequence & Mismatch Analysis","text":"","code":"calculateMismatchLoad(rgeno, dgeno, parallel = FALSE) #> [1] 310"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"per-locus-breakdown","dir":"Articles","previous_headings":"Donor-Recipient Mismatch Load","what":"Per-Locus Breakdown","title":"Sequence & Mismatch Analysis","text":"","code":"per_locus <- calculateMismatchLoad(   rgeno, dgeno,   return = \"per_locus\",   parallel = FALSE ) per_locus #>   locus mismatch_load #> 1     A            96 #> 2     B           128 #> 3  DRB1            86"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"pairwise-allele-matrix","dir":"Articles","previous_headings":"Donor-Recipient Mismatch Load","what":"Pairwise Allele Matrix","title":"Sequence & Mismatch Analysis","text":"View mismatches recipient-donor allele pair:","code":"mB <- calculateMismatchLoad(   rgeno, dgeno,   return = \"pairwise\",   pairwise_locus = \"B\",   parallel = FALSE ) mB #>          donor #> recipient B*44:02 B*51:01 #>   B*07:02      37      33 #>   B*08:01      31      27"},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"applying-filters","dir":"Articles","previous_headings":"Donor-Recipient Mismatch Load","what":"Applying Filters","title":"Sequence & Mismatch Analysis","text":"","code":"# Charge-changing mismatches only calculateMismatchLoad(rgeno, dgeno, filter_charge = TRUE, parallel = FALSE) #> [1] 123  # Polarity-changing mismatches only calculateMismatchLoad(rgeno, dgeno, filter_polarity = TRUE, parallel = FALSE) #> [1] 108  # Restrict to specific loci calculateMismatchLoad(rgeno, dgeno, loci = c(\"A\", \"B\"), parallel = FALSE) #> [1] 224"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/articles/sequence-analysis.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session Information","title":"Sequence & Mismatch Analysis","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] dplyr_1.1.4       deepMatchR_0.99.0 BiocStyle_2.38.0  #>  #> loaded via a namespace (and not attached): #>  [1] sass_0.4.10         generics_0.1.4      xml2_1.5.2          #>  [4] lattice_0.22-7      immReferent_0.99.6  digest_0.6.39       #>  [7] magrittr_2.0.4      evaluate_1.0.5      grid_4.5.2          #> [10] RColorBrewer_1.1-3  bookdown_0.46       fastmap_1.2.0       #> [13] cellranger_1.1.0    jsonlite_2.0.0      Matrix_1.7-4        #> [16] BiocManager_1.30.27 rvest_1.0.5         httr_1.4.7          #> [19] scales_1.4.0        Biostrings_2.78.0   textshaping_1.0.4   #> [22] jquerylib_0.1.4     cli_3.6.5           rlang_1.1.7         #> [25] crayon_1.5.3        XVector_0.50.0      cachem_1.1.0        #> [28] yaml_2.3.12         tools_4.5.2         dir.expiry_1.18.0   #> [31] parallel_4.5.2      memoise_2.0.1       ggplot2_4.0.1       #> [34] filelock_1.0.3      basilisk_1.22.0     BiocGenerics_0.56.0 #> [37] reticulate_1.44.1   vctrs_0.7.1         R6_2.6.1            #> [40] png_0.1-8           stats4_4.5.2        lifecycle_1.0.5     #> [43] pwalign_1.6.0       Seqinfo_1.0.0       IRanges_2.44.0      #> [46] S4Vectors_0.48.0    fs_1.6.6            ragg_1.5.0          #> [49] pkgconfig_2.0.3     desc_1.4.3          pkgdown_2.2.0       #> [52] pillar_1.11.1       bslib_0.9.0         gtable_0.3.6        #> [55] data.table_1.18.0   glue_1.8.0          Rcpp_1.1.1          #> [58] systemfonts_1.3.1   xfun_0.56           tibble_3.3.1        #> [61] tidyselect_1.2.1    knitr_1.51          farver_2.1.2        #> [64] patchwork_1.3.2     htmltools_0.5.9     rmarkdown_2.30      #> [67] compiler_4.5.2      S7_0.2.1            readxl_1.4.5"},{"path":"https://www.borch.dev/uploads/deepMatchR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Nick Borcherding. Author, maintainer.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Borcherding N (2026). deepMatchR: Deep Learning Models HLA Matching. R package version 0.99.0, https://www.borch.dev/uploads/deepMatchR.","code":"@Manual{,   title = {deepMatchR: Deep Learning Models for HLA Matching},   author = {Nick Borcherding},   year = {2026},   note = {R package version 0.99.0},   url = {https://www.borch.dev/uploads/deepMatchR}, }"},{"path":"https://www.borch.dev/uploads/deepMatchR/index.html","id":"deepmatchr","dir":"","previous_headings":"","what":"deepMatchR - Deep Learning Models for HLA Matching","title":"deepMatchR - Deep Learning Models for HLA Matching","text":"Tools HLA Testing Matching","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"deepMatchR - Deep Learning Models for HLA Matching","text":"currently several computational approaches quantifying risk development donor-specific antibodies organ transplantation. include HLAmatchmaker eplet quantification PIRCHE-II CD4+ T cell epitope prediction, demonstrated predictive ability across literature. Newer deep learning methods structure predictions, eplet/epitope immunogenicity estimates, classification can leveraged produce clinical tool patients. deepMatchR aims centralized repository tools models help assisting HLA matching.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/index.html","id":"core-functions","dir":"","previous_headings":"","what":"Core Functions","title":"deepMatchR - Deep Learning Models for HLA Matching","text":"deepMatchR provides suite functions HLA analysis, basic sequence comparison complex visualization deconvolution. overview main functions:","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/index.html","id":"sequence--eplet-analysis","dir":"","previous_headings":"Core Functions","what":"Sequence & Eplet Analysis","title":"deepMatchR - Deep Learning Models for HLA Matching","text":"getAlleleSequence(allele_name): Retrieves full amino acid sequence given HLA allele IMGT/HLA database. quantifyMismatch(seq1, seq2): Calculates total number amino acid mismatches two sequences. quantifyEpletMismatch(allele1, allele2): Calculates number mismatched eplets two HLA alleles based internal eplet registry.","code":"# Note: Requires internet connection getAlleleSequence(\"A*01:01\") seq1 <- \"YFAMYGEKVAHTHVDTLYVRYHY\" seq2 <- \"YFDMYGEKVAHTHVDTLYVRFHY\" quantifyMismatch(seq1, seq2) quantifyEpletMismatch(\"A*01:01\", \"A*02:01\")"},{"path":"https://www.borch.dev/uploads/deepMatchR/index.html","id":"antibody-analysis--visualization","dir":"","previous_headings":"Core Functions","what":"Antibody Analysis & Visualization","title":"deepMatchR - Deep Learning Models for HLA Matching","text":"plotAntibodies(result_file, type): Visualizes SAB PRA results bar plot, optional table antigen specificities. plotEplets(result_file, plot_type): Visualizes eplet-level reactivity SAB results using treemap, bar plot, AUC plot. calculateAUC(...) / epletAUC(...): Calculates Area Curve (AUC) feature reactivity (like eplets CREGs) across range MFI cutoffs.","code":"data(deepMatchR_example) plotAntibodies(deepMatchR_example[[1]], type = \"SAB\") data(deepMatchR_example) plotEplets(deepMatchR_example[[1]], plot_type = \"treemap\") data(deepMatchR_example) epletAUC(deepMatchR_example[[1]], plot_results = TRUE)"},{"path":"https://www.borch.dev/uploads/deepMatchR/index.html","id":"peptide-binding-prediction","dir":"","previous_headings":"Core Functions","what":"Peptide Binding Prediction","title":"deepMatchR - Deep Learning Models for HLA Matching","text":"predictMHCnuggets(peptides, allele): Predicts peptide-MHC binding affinity using MHCnuggets, deep learning model MHC binding prediction. calculatePeptideBindingLoad(recipient, donor): Estimates transplant risk predicting peptide-HLA binding recipient HLA molecules donor-mismatched peptides. Supports multiple backends: pwm: Built-position weight matrix (external dependencies) mhcnuggets: Deep learning via MHCnuggets netmhcpan: External tool via NetMHCpan 4.1","code":"peptides <- c(\"SIINFEKL\", \"LLFGYPVYV\", \"GILGFVFTL\") predictMHCnuggets(peptides, allele = \"A*02:01\", mhc_class = \"I\") recipient <- hlaGeno(data.frame(A_1 = \"A*02:01\", A_2 = \"A*03:01\")) donor <- hlaGeno(data.frame(A_1 = \"A*01:01\", A_2 = \"A*24:02\")) calculatePeptideBindingLoad(recipient, donor, return = \"summary\")"},{"path":"https://www.borch.dev/uploads/deepMatchR/index.html","id":"system-requirements","dir":"","previous_headings":"","what":"System requirements","title":"deepMatchR - Deep Learning Models for HLA Matching","text":"deepMatchR tested R versions >= 4.5. Please consult DESCRIPTION file details required R packages. deepMatchR tested OS X Windows platforms.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/index.html","id":"setting-up-netmhcpan-optional","dir":"","previous_headings":"System requirements","what":"Setting up NetMHCpan (Optional)","title":"deepMatchR - Deep Learning Models for HLA Matching","text":"use netmhcpan backend peptide binding prediction, need install NetMHCpan 4.1 separately: Request license: Go https://services.healthtech.dtu.dk/services/NetMHCpan-4.1/ request academic license (free academic users). Download extract: receiving download link via email, extract archive: Configure installation: Edit netMHCpan script set correct paths: Download data files: Follow instructions netMHCpan-4.1.readme file download required data files place data directory. Test installation: Use deepMatchR: Provide path executable: Note: NetMHCpan available Linux macOS. Windows users use WSL (Windows Subsystem Linux) pwm/mhcnuggets backends instead.","code":"tar -xzvf netMHCpan-4.1.Linux.tar.gz cd netMHCpan-4.1 # Open the script and modify these lines: setenv NMHOME /path/to/netMHCpan-4.1 setenv TMPDIR /tmp ./netMHCpan -p test.pep -a HLA-A02:01 calculatePeptideBindingLoad(   recipient = rgeno,   donor = dgeno,   backend = \"netmhcpan\",   backend_path = \"/path/to/netMHCpan-4.1/netMHCpan\" )"},{"path":"https://www.borch.dev/uploads/deepMatchR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"deepMatchR - Deep Learning Models for HLA Matching","text":"run deepMatchR, open R install deepMatchR github:","code":"devtools::install_github(\"BorchLab/deepMatchR\")"},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/index.html","id":"if-you-run-into-any-issues-or-bugs-please-submit-a-github-issue-with-details-of-the-issue","dir":"","previous_headings":"Bug Reports/New Features","what":"If you run into any issues or bugs please submit a GitHub issue with details of the issue.","title":"deepMatchR - Deep Learning Models for HLA Matching","text":"possible please include reproducible example. Alternatively, example internal deepMatchR_example extremely helpful.","code":""},{"path":[]},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/batchGetSequences.html","id":null,"dir":"Reference","previous_headings":"","what":"Batch Get Sequences with Parallel Processing — batchGetSequences","title":"Batch Get Sequences with Parallel Processing — batchGetSequences","text":"Retrieves sequences multiple alleles parallel better performance. Supports nucleotide protein sequences.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/batchGetSequences.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Batch Get Sequences with Parallel Processing — batchGetSequences","text":"","code":"batchGetSequences(   alleles,   type = c(\"PROT\", \"NUC\"),   n_cores = 2,   use_cache = TRUE,   cache_dir = NULL,   verbose = FALSE )"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/batchGetSequences.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Batch Get Sequences with Parallel Processing — batchGetSequences","text":"alleles Character vector HLA allele names type type sequence retrieve. Either \"NUC\" nucleotide \"PROT\" protein sequences (default \"PROT\") n_cores Number cores use (default: detectCores() - 1) use_cache Whether use caching (default TRUE) cache_dir Optional directory persistent cache verbose Logical, whether print progress messages (default FALSE)","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/batchGetSequences.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Batch Get Sequences with Parallel Processing — batchGetSequences","text":"Named list sequences","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/batchGetSequences.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Batch Get Sequences with Parallel Processing — batchGetSequences","text":"","code":"# Get protein sequences for multiple alleles alleles <- c(\"A*01:01\", \"A*02:01\", \"B*07:02\", \"B*08:01\") prot_seqs <- batchGetSequences(alleles, type = \"PROT\") #> Creating immReferent cache directory at: /home/runner/.immReferent  # Get nucleotide sequences with parallel processing nuc_seqs <- batchGetSequences(alleles, type = \"NUC\", n_cores = 4)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateAUC.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Antigen AUC Based on MFI — calculateAUC","title":"Calculate Antigen AUC Based on MFI — calculateAUC","text":"function provides unified interface analyzing Single Antigen Bead (SAB) data different antigenic features, eplets, cross-reactive groups (CREGs), serology. computes proportion features positive sequence MFI cut-offs integrates obtain area---curve (AUC). Depending user arguments, can either generate ggplot return AUC results data.frame.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateAUC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Antigen AUC Based on MFI — calculateAUC","text":"","code":"calculateAUC(   result_file,   analysis_type,   feature_filter = 3,   percPos_filter = 0.8,   group_by = NULL,   label = TRUE,   cut_min = 250,   cut_max = 10000,   cut_step = 250,   plot_results = TRUE,   palette = \"spectral\",   evidence_level = c(\"A1\", \"A2\"),   eplet_filter = 3,   top_eplets = 10,   creg_filter = 3,   serology_filter = NULL,   ... )  epletAUC(   result_file,   evidence_level = c(\"A1\", \"A2\"),   eplet_filter = 3,   top_eplets = 10,   ... )  cregAUC(result_file, creg_filter = 3, ...)  serologyAUC(result_file, serology_filter = 3, ...)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateAUC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Antigen AUC Based on MFI — calculateAUC","text":"result_file data frame SAB results path CSV/XLS/XLSX file. analysis_type Character. type analysis perform. Must one `\"eplet\"`, `\"creg\"`, `\"serology\"`. feature_filter Integer. minimum number beads/alleles must carry feature included analysis. Defaults `3`. percPos_filter Numeric (0-1). minimum proportion beads must positive least one cut-keep feature. Defaults `0.8`. group_by Character. aesthetic used color curves plot. label Logical. `TRUE`, labels curves plot. Defaults `TRUE`. cut_min, cut_max, cut_step Range step MFI cut-offs. plot_results Logical. `TRUE` (default), returns `ggplot` object. `FALSE`, returns summarized tibble AUC results. palette Character. color palette name (see `grDevices::hcl.pals`) custom palette function. Defaults `\"spectral\"`. evidence_level eplet analysis, character vector evidence levels keep. eplet_filter eplet analysis, minimum number times eplet must appear. top_eplets eplet analysis, maximum number top eplets display. creg_filter CREG analysis, minimum number times CREG must appear. serology_filter serology analysis, filter applied. ... Additional arguments passed plot theme.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateAUC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Antigen AUC Based on MFI — calculateAUC","text":"Either `ggplot` object data.frame AUC results. data.frame   contain columns feature (`eplet`, `creg`, `serology`), `AUC`,   `norm_AUC`, `total_count`, `loci`.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateAUC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Antigen AUC Based on MFI — calculateAUC","text":"","code":"# Calculate eplet AUC epletAUC(deepMatchR_example[[1]])   # Get data instead of plot auc_data <- epletAUC(deepMatchR_example[[1]], plot_results = FALSE) head(auc_data) #>     eplet      AUC total_count   loci  norm_AUC #>    <char>    <num>       <int> <char>     <num> #> 1:   82LR 7817.708          24   A; B 0.7817708 #> 2:    80I 7022.059          17   A; B 0.7022059 #> 3:   69AA 5641.667          15      B 0.5641667 #> 4:  163EW 6691.667          15   A; B 0.6691667 #> 5:    41T 9583.333          12      B 0.9583333 #> 6:  65QIA 4761.364          11      B 0.4761364  # Calculate CREG AUC cregAUC(deepMatchR_example[[1]])"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateEpletLoad.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Eplet Load Between Donor and Recipient Genotypes — calculateEpletLoad","title":"Calculate Eplet Load Between Donor and Recipient Genotypes — calculateEpletLoad","text":"Aggregates **donor-specific eplets** (present donor, absent recipient) loci. Can return single total, per-locus summary, pairwise recipient-vs-donor allele matrix chosen locus. Supports filtering **evidence**, **exposition**, **reactivity**.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateEpletLoad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Eplet Load Between Donor and Recipient Genotypes — calculateEpletLoad","text":"","code":"calculateEpletLoad(   recipient_geno,   donor_geno,   loci = NULL,   evidence_level = c(\"A1\", \"A2\"),   exposition_filter = NULL,   reactivity_filter = NULL,   return = c(\"total\", \"per_locus\", \"pairwise\"),   pairwise_locus = NULL )"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateEpletLoad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Eplet Load Between Donor and Recipient Genotypes — calculateEpletLoad","text":"recipient_geno, donor_geno `hla_genotype` objects. loci Character vector loci include (e.g. `c(\"\",\"B\",\"C\")`), `NULL` (default) shared loci. evidence_level Character vector evidence levels include (default `c(\"A1\",\"A2\")`). Use `NULL` evidence filter. exposition_filter Character vector exposition classes include; `NULL` filter. reactivity_filter Character vector reactivity classes include; `NULL` filter. return return: `\"total\"` (default), `\"per_locus\"`, `\"pairwise\"`. pairwise_locus `return = \"pairwise\"`, single locus compute (e.g., `\"B\"`). Ignored otherwise.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateEpletLoad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Eplet Load Between Donor and Recipient Genotypes — calculateEpletLoad","text":"- `return=\"total\"`: integer total donor-specific eplet load. - `return=\"per_locus\"`: `data.frame` columns `locus`, `eplet_load`. - `return=\"pairwise\"`: numeric matrix entry `[,j]` count   donor-specific eplets donor allele `j` vs recipient allele `` `pairwise_locus`.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateEpletLoad.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Eplet Load Between Donor and Recipient Genotypes — calculateEpletLoad","text":"","code":"# Dummy genotypes recipient <- data.frame(   A_1 = \"A*01:01\", A_2 = \"A*02:01\",   B_1 = \"B*07:02\", B_2 = \"B*08:01\" ) donor <- data.frame(   A_1 = \"A*03:01\", A_2 = \"A*24:02\",   B_1 = \"B*44:02\", B_2 = \"B*51:01\" ) rgeno <- hlaGeno(recipient); dgeno <- hlaGeno(donor)  # Total donor-specific eplet load (A1/A2 evidence) calculateEpletLoad(rgeno, dgeno) #> [1] 10  # Per locus calculateEpletLoad(rgeno, dgeno, return = \"per_locus\") #>   locus eplet_load #> 1     A          4 #> 2     B          6  # Pairwise matrix for B locus (rows=recipient alleles, cols=donor alleles) mB <- calculateEpletLoad(rgeno, dgeno, return = \"pairwise\", pairwise_locus = \"B\") mB #>          donor #> recipient B*44:02 B*51:01 #>   B*07:02       5       4 #>   B*08:01       4       3  # Apply additional filters calculateEpletLoad(rgeno, dgeno, exposition_filter = \"High\") #> [1] 8 calculateEpletLoad(rgeno, dgeno, reactivity_filter = c(\"IgG\")) #> [1] 0"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateMismatchLoad.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Mismatch Load Between Donor and Recipient Genotypes — calculateMismatchLoad","title":"Calculate Mismatch Load Between Donor and Recipient Genotypes — calculateMismatchLoad","text":"Computes amino-acid mismatch burden donor recipient across HLA loci calling `quantifyMismatch()` recipient–donor allele pair per locus. Can return (1) single total, (2) per-locus summary table, (3) pairwise recipient-vs-donor allele matrix one locus.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateMismatchLoad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Mismatch Load Between Donor and Recipient Genotypes — calculateMismatchLoad","text":"","code":"calculateMismatchLoad(   recipient_geno,   donor_geno,   loci = NULL,   filter_charge = NULL,   filter_polarity = NULL,   na_action = c(\"exclude\", \"error\", \"count\"),   return = c(\"total\", \"per_locus\", \"pairwise\"),   pairwise_locus = NULL,   parallel = TRUE,   n_cores = 2 )"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateMismatchLoad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Mismatch Load Between Donor and Recipient Genotypes — calculateMismatchLoad","text":"recipient_geno `hla_genotype` object recipient. donor_geno `hla_genotype` object donor. loci Character vector loci include (e.g., c(\"\",\"B\",\"C\")), NULL use shared loci. filter_charge NULL/TRUE/FALSE. Passed [quantifyMismatch()]. filter_polarity NULL/TRUE/FALSE. Passed [quantifyMismatch()]. na_action One \"exclude\" (default), \"error\", \"count\". Passed . return return: \"total\" (default), \"per_locus\", \"pairwise\". pairwise_locus `return = \"pairwise\"`, locus visualize (e.g., \"\", \"B\", \"C\"). Ignored otherwise. parallel Logical, whether use parallel processing n_cores Number cores parallel processing","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateMismatchLoad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Mismatch Load Between Donor and Recipient Genotypes — calculateMismatchLoad","text":"- `return = \"total\"`: single integer total mismatch load. - `return = \"per_locus\"`: data.frame columns `locus`, `mismatch_load`. - `return = \"pairwise\"`: numeric matrix pairwise counts (rows = recipient alleles,   columns = donor alleles) `pairwise_locus`.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculateMismatchLoad.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Mismatch Load Between Donor and Recipient Genotypes — calculateMismatchLoad","text":"","code":"# Toy genotypes recipient <- data.frame(   A_1 = \"A*01:01\", A_2 = \"A*02:01\",   B_1 = \"B*07:02\", B_2 = \"B*08:01\" ) donor <- data.frame(   A_1 = \"A*01:01\", A_2 = \"A*03:01\",   B_1 = \"B*44:02\", B_2 = \"B*51:01\" ) rgeno <- hlaGeno(recipient) dgeno <- hlaGeno(donor)  # 1) Total load (all loci, all mismatches) calculateMismatchLoad(rgeno, dgeno) #> [1] 199  # 2) Per-locus summary calculateMismatchLoad(rgeno,                        dgeno,                        return = \"per_locus\") #>   locus mismatch_load #> 1     A            71 #> 2     B           128  # 3) Pairwise matrix for B locus mB <- calculateMismatchLoad(rgeno,                              dgeno,                              return = \"pairwise\",                              pairwise_locus = \"B\") mB #>          donor #> recipient B*44:02 B*51:01 #>   B*07:02      37      33 #>   B*08:01      31      27  # 4) Apply biophysical filters # charge-changing only calculateMismatchLoad(rgeno,                        dgeno,                        filter_charge = TRUE)                #> [1] 75  # polarity-changing only calculateMismatchLoad(rgeno,                        dgeno,                        filter_polarity = TRUE)              #> [1] 66  # Both polarity and charge-changing calculateMismatchLoad(rgeno,                        dgeno,                        filter_charge = TRUE,                        filter_polarity = TRUE)  #> [1] 26"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculatePeptideBindingLoad.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Peptide Binding Load for Transplant Risk Assessment — calculatePeptideBindingLoad","title":"Calculate Peptide Binding Load for Transplant Risk Assessment — calculatePeptideBindingLoad","text":"Predicts transplant risk calculating peptide-HLA binding affinities recipient HLA molecules donor-mismatched peptides. Supports multiple binding prediction backends: built-position weight matrix (PWM), NetMHCpan, MHCnuggets.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculatePeptideBindingLoad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Peptide Binding Load for Transplant Risk Assessment — calculatePeptideBindingLoad","text":"","code":"calculatePeptideBindingLoad(   recipient,   donor,   backend = c(\"pwm\", \"netmhcpan\", \"mhcnuggets\"),   backend_path = NULL,   peptide_length = 9L,   binding_threshold = 500,   weak_threshold = 5000,   return = c(\"total\", \"summary\", \"detail\"),   aggregate_method = c(\"sum\", \"max\", \"mean\") )"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculatePeptideBindingLoad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Peptide Binding Load for Transplant Risk Assessment — calculatePeptideBindingLoad","text":"recipient `hla_genotype` object character vector HLA allele names. donor `hla_genotype` object, character vector HLA allele names, character vector peptide sequences. `hla_genotype` allele names, mismatched peptides derived automatically sequence differences. backend Character. Binding prediction method: `\"pwm\"` (default, external dependencies), `\"netmhcpan\"`, `\"mhcnuggets\"`. backend_path Character. Path external tool executable. Required `\"netmhcpan\"` backend. Download NetMHCpan   https://services.healthtech.dtu.dk/services/NetMHCpan-4.1/. peptide_length Integer. Peptide length(s) consider. Default `9L`. binding_threshold Numeric. IC50 threshold (nM) \"strong binder\". Default `500`. weak_threshold Numeric. IC50 threshold (nM) \"weak binder\". Default `5000`. return Character. One `\"total\"` (risk score), `\"summary\"` (per-allele), `\"detail\"` (per-peptide table). Default `\"total\"`. aggregate_method Character. combine per-peptide scores: `\"sum\"`, `\"max\"`, `\"mean\"`. Default `\"sum\"`.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculatePeptideBindingLoad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Peptide Binding Load for Transplant Risk Assessment — calculatePeptideBindingLoad","text":"Depends `return`:   - `\"total\"`: Numeric risk score.   - `\"summary\"`: data.frame per-HLA-allele binding summary.   - `\"detail\"`: data.frame columns: `peptide`, `hla_allele`, `predicted_ic50`,     `binding_level`, `contribution`.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculatePeptideBindingLoad.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Peptide Binding Load for Transplant Risk Assessment — calculatePeptideBindingLoad","text":"function works several steps: 1. **Input processing**: Converts inputs standard format (allele names peptides) 2. **Peptide derivation**: donor genotype/alleles, derives mismatched peptides    comparing sequences generating overlapping k-mers mismatch regions 3. **Binding prediction**: Uses selected backend predict IC50 values 4. **Risk calculation**: Aggregates binding predictions risk score **PWM backend** uses simplified position weight matrices based HLA supertypes. production use high accuracy requirements, NetMHCpan MHCnuggets recommended. **External backends:** - **NetMHCpan**: state---art method predicting peptide-MHC class binding   using artificial neural networks. Available   https://services.healthtech.dtu.dk/services/NetMHCpan-4.1/. - **MHCnuggets**: deep learning approach MHC binding prediction. Available   https://github.com/KarchinLab/mhcnuggets. See predictMHCnuggets   direct access MHCnuggets predictions. Risk score formula: $$contribution = (1 - IC50/weak\\_threshold) \\times multiplier$$ multiplier 2 strong binders, 1 weak binders.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculatePeptideBindingLoad.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate Peptide Binding Load for Transplant Risk Assessment — calculatePeptideBindingLoad","text":"Reynisson B, et al. (2020). NetMHCpan-4.1 NetMHCIIpan-4.0: improved predictions MHC antigen presentation concurrent motif deconvolution integration MS MHC eluted ligand data. *Nucleic Acids Research*, 48(W1), W449-W454. doi:10.1093/nar/gkaa379 Shao XM, et al. (2020). High-Throughput Prediction MHC Class II Neoantigens MHCnuggets. *Cancer Immunology Research*, 8(3), 396-408. doi:10.1158/2326-6066.CIR-19-0464","code":""},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/calculatePeptideBindingLoad.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Peptide Binding Load for Transplant Risk Assessment — calculatePeptideBindingLoad","text":"","code":"# Example 1: Using raw peptides (no external data required) # Define recipient HLA alleles recipient_alleles <- c(\"A*02:01\", \"A*03:01\", \"B*07:02\", \"B*08:01\")  # Define peptides to test peptides <- c(\"GILGFVFTL\", \"NLVPMVATV\", \"FLKEKGGL\", \"SIINFEKL\")  # Calculate binding load with PWM backend result <- calculatePeptideBindingLoad(   recipient = recipient_alleles,   donor = peptides,   backend = \"pwm\",   return = \"summary\" ) print(result) #>   hla_allele n_peptides n_strong n_weak risk_contribution #> 1    A*02:01          2        0      2              1.75 #> 2    A*03:01          2        0      2              1.75 #> 3    B*07:02          2        0      2              1.25 #> 4    B*08:01          2        0      2              1.25  # Get detailed per-peptide results detail <- calculatePeptideBindingLoad(   recipient = recipient_alleles,   donor = peptides,   backend = \"pwm\",   return = \"detail\" ) head(detail) #>     peptide hla_allele predicted_ic50 binding_level contribution #> 1 GILGFVFTL    A*02:01            625          weak        0.875 #> 2 NLVPMVATV    A*02:01            625          weak        0.875 #> 3 GILGFVFTL    A*03:01            625          weak        0.875 #> 4 NLVPMVATV    A*03:01            625          weak        0.875 #> 5 GILGFVFTL    B*07:02           1250          weak        0.750 #> 6 NLVPMVATV    B*07:02           2500          weak        0.500  # Example 2: Using hla_genotype objects with peptides recipient <- data.frame(   A_1 = \"A*02:01\", A_2 = \"A*03:01\",   B_1 = \"B*07:02\", B_2 = \"B*44:02\" ) rgeno <- hlaGeno(recipient)  # Calculate total risk score total_risk <- calculatePeptideBindingLoad(   recipient = rgeno,   donor = peptides,   return = \"total\" ) print(total_risk) #> [1] 6  # \\donttest{ # Example 3: Using genotypes (requires IMGT database connection) donor <- data.frame(   A_1 = \"A*01:01\", A_2 = \"A*24:02\",   B_1 = \"B*08:01\", B_2 = \"B*35:01\" ) dgeno <- hlaGeno(donor)  # Calculate binding load from sequence mismatches calculatePeptideBindingLoad(rgeno, dgeno, return = \"summary\") #>   hla_allele n_peptides n_strong n_weak risk_contribution #> 1    A*02:01        624        0    354            195.25 #> 2    A*03:01        624        0    354            195.25 #> 3    B*07:02        624        0    299             69.00 #> 4    B*44:02        624        0    299             69.00 # }"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/clearSequenceCache.html","id":null,"dir":"Reference","previous_headings":"","what":"Clear Sequence Cache — clearSequenceCache","title":"Clear Sequence Cache — clearSequenceCache","text":"Utility function clear sequence cache, either -memory filesystem-based.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/clearSequenceCache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clear Sequence Cache — clearSequenceCache","text":"","code":"clearSequenceCache(cache_dir = NULL, type = NULL)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/clearSequenceCache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clear Sequence Cache — clearSequenceCache","text":"cache_dir provided, clears filesystem cache location. NULL, clears -memory cache current session. type provided, clears cache entries sequence type. Options: \"PROT\", \"NUC\", NULL types.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/clearSequenceCache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clear Sequence Cache — clearSequenceCache","text":"Invisible NULL","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/clearSequenceCache.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clear Sequence Cache — clearSequenceCache","text":"","code":"# Clear in-memory cache clearSequenceCache() #> Note: In-memory cache clearing requires restarting R session or re-sourcing functions  # Clear filesystem cache clearSequenceCache(cache_dir = \"~/.hla_cache\") #> Cache directory does not exist"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/clearWmdaCache.html","id":null,"dir":"Reference","previous_headings":"","what":"Clear WMDA Cache — clearWmdaCache","title":"Clear WMDA Cache — clearWmdaCache","text":"Removes cached WMDA data, causing toSerology revert using bundled package data.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/clearWmdaCache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clear WMDA Cache — clearWmdaCache","text":"","code":"clearWmdaCache(cache_dir = NULL, verbose = TRUE)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/clearWmdaCache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clear WMDA Cache — clearWmdaCache","text":"cache_dir Character. Directory containing cached data. NULL, uses default cache location. verbose Logical. TRUE (default), print status message.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/clearWmdaCache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clear WMDA Cache — clearWmdaCache","text":"Invisibly returns TRUE cache cleared, FALSE cache existed.","code":""},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/clearWmdaCache.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clear WMDA Cache — clearWmdaCache","text":"","code":"# Check if cache exists (safe operation, no side effects) cache_dir <- file.path(tempdir(), \"wmda_cache_test\") # This will report \"No WMDA cache found\" since we use a temp directory clearWmdaCache(cache_dir = cache_dir) #> No WMDA cache found  # \\donttest{ # Clear the default WMDA cache clearWmdaCache() #> No WMDA cache found # }"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_cregs.html","id":null,"dir":"Reference","previous_headings":"","what":"CREG–Allele Mapping Data — deepMatchR_cregs","title":"CREG–Allele Mapping Data — deepMatchR_cregs","text":"curated mapping IMGT/HLA allele strings corresponding serologic antigen assignments Cross-Reactive Groups (CREGs). table intended convenience functions summarize antibody specificity, collapse alleles serology, group responses CREG reporting.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_cregs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CREG–Allele Mapping Data — deepMatchR_cregs","text":"","code":"data(deepMatchR_cregs)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_cregs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"CREG–Allele Mapping Data — deepMatchR_cregs","text":"data frame following variables: allele `character`. IMGT/HLA allele (e.g., `\"B*07:02\"`). serology `character`. Serologic antigen assignment (e.g., `\"B7\"`). CREG `character`. Cross-Reactive Group label (e.g., `\"CREG07\"`).","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_cregs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"CREG–Allele Mapping Data — deepMatchR_cregs","text":"- **Allele strings** follow IMGT/HLA nomenclature (e.g., `\"*02:01\"`). - **Serology** uses conventional two-digit antigen labels (e.g., `\"A2\"`,   `\"B8\"`). Depending workflow, may want harmonize   vendor-specific naming. - **CREG** indicates cross-reactive group label used many transplant   workflows approximate serologic cross-reactivity.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_cregs.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CREG–Allele Mapping Data — deepMatchR_cregs","text":"Source internal curation aligned common CREG practice; see   package vignette curation notes limitations. Always verify   lab’s approved references.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_cregs.html","id":"typical-use","dir":"Reference","previous_headings":"","what":"Typical use","title":"CREG–Allele Mapping Data — deepMatchR_cregs","text":"- Collapsing allele-level reactivity serology/CREG. - Building summary tables/plots serology CREG.","code":""},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_eplets.html","id":null,"dir":"Reference","previous_headings":"","what":"HLA Eplet Assignments (Registry-derived) — deepMatchR_eplets","title":"HLA Eplet Assignments (Registry-derived) — deepMatchR_eplets","text":"Per-allele eplet annotations derived HLA Epitope Registry, filtered retain evidence classes A1, A2, B, D. row links eplet HLA allele along Registry metadata fields commonly used analysis.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_eplets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"HLA Eplet Assignments (Registry-derived) — deepMatchR_eplets","text":"","code":"data(deepMatchR_eplets)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_eplets.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"HLA Eplet Assignments (Registry-derived) — deepMatchR_eplets","text":"data frame 5 variables: eplet `character`. Eplet identifier. exposition `character`. Structural/surface exposure categorization. reactivity `character` `NA`. Registry reactivity note/flag. evidence `character`. Evidence class; subset {A1, A2, B, D}. allele `character`. IMGT/HLA allele string.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_eplets.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"HLA Eplet Assignments (Registry-derived) — deepMatchR_eplets","text":"HLA Epitope Registry (https://www.epregistry.com.br/); processed   filtered package authors reproducible analyses.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_eplets.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"HLA Eplet Assignments (Registry-derived) — deepMatchR_eplets","text":"**Field meanings (used package):** eplet: Short alphanumeric eplet identifier (e.g., `\"82LR\"`, `\"1C\"`). exposition: Qualitative description surface exposure         structural context (e.g., `\"High\"`). reflects Registry’s         exposition field. reactivity: Free-text/flag describing observed reactivity         patterns Registry (often `NA` specified). evidence: Evidence class label Registry; records         dataset filtered A1, A2, B, D. allele: IMGT/HLA allele string eplet         assigned (e.g., `\"B*07:02\"`).","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_eplets.html","id":"caveats","dir":"Reference","previous_headings":"","what":"Caveats","title":"HLA Eplet Assignments (Registry-derived) — deepMatchR_eplets","text":"- Registry living resource; re-download update cache   regularly production use. - Evidence codes indicate strength/quality support equivalent   clinical validity. Apply lab’s validation cutoffs.","code":""},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Example SAB (Class I/II) and PRA Panels — deepMatchR_example","title":"Example SAB (Class I/II) and PRA Panels — deepMatchR_example","text":"small, fixed-format example object demonstrating input structure used package’s utilities single antigen bead (SAB) Class / Class II panel reactive antibody (PRA) data. Useful examples, vignettes, unit tests without requiring PHI proprietary vendor exports.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example SAB (Class I/II) and PRA Panels — deepMatchR_example","text":"","code":"data(deepMatchR_example)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_example.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example SAB (Class I/II) and PRA Panels — deepMatchR_example","text":"named list length 3 containing data frames described .","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_example.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example SAB (Class I/II) and PRA Panels — deepMatchR_example","text":"Structure: named list length 3: ClassI_example: data frame columns     BeadID (`integer`), SpecAbbr (`character`, antigen abbreviations),     Specificity (`character`, comma-delimited allele list),     NormalValue (`numeric`, normalized MFI vendor-provided normalization),     RawData (`numeric`, raw MFI), CountValue (`integer`, bead/event count). ClassII_example: schema Class , class II     specificities (e.g., DR, DQ, DP). PRA: data frame columns     BeadID (`integer`), SpecAbbr (`character`),     Specificity (`character`), NormalValue (`numeric` `NA`),     RawData (`numeric`), CountValue (`integer`). Notes: - Column names kept vendor-agnostic mimic common exports. - SpecAbbr values comma-separated antigen abbreviations   padding dashes, e.g., `\"A2,-,-,-,...\"`. - Specificity values comma-separated IMGT/HLA alleles aligned   abbreviations SpecAbbr. - NormalValue may NA supplied instrument   export illustrative .","code":""},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_pgroups.html","id":null,"dir":"Reference","previous_headings":"","what":"WMDA P-Group Definitions — deepMatchR_wmda_pgroups","title":"WMDA P-Group Definitions — deepMatchR_wmda_pgroups","text":"lookup table containing HLA P-group definitions WMDA nomenclature. P-groups sets alleles identical protein sequences antigen recognition site. Used internally toSerology resolve P-group notation.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_pgroups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"WMDA P-Group Definitions — deepMatchR_wmda_pgroups","text":"","code":"data(deepMatchR_wmda_pgroups)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_pgroups.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"WMDA P-Group Definitions — deepMatchR_wmda_pgroups","text":"data.table following columns: locus `character`. HLA locus (e.g., `\"\"`, `\"B\"`, `\"DRB1\"`). p_group `character`. P-group designation (e.g., `\"01:01P\"`). reference_2f `character`. Reference two-field allele P-group.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_pgroups.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"WMDA P-Group Definitions — deepMatchR_wmda_pgroups","text":"WMDA nomenclature files IMGT/HLA GitHub repository   (https://github.com/ANHIG/IMGTHLA/tree/Latest/wmda).","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_pgroups.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"WMDA P-Group Definitions — deepMatchR_wmda_pgroups","text":"P-group notation (e.g., `\"*01:01P\"`) indicates multiple alleles share protein sequence antigen recognition domain. table maps P-groups representative reference alleles serology lookup.","code":""},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_serology.html","id":null,"dir":"Reference","previous_headings":"","what":"WMDA DNA-to-Serology Mapping — deepMatchR_wmda_serology","title":"WMDA DNA-to-Serology Mapping — deepMatchR_wmda_serology","text":"lookup table mapping HLA alleles serological equivalents based WMDA (World Marrow Donor Association) nomenclature. Used internally toSerology allele--serology conversion.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_serology.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"WMDA DNA-to-Serology Mapping — deepMatchR_wmda_serology","text":"","code":"data(deepMatchR_wmda_serology)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_serology.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"WMDA DNA-to-Serology Mapping — deepMatchR_wmda_serology","text":"data.table following columns: locus `character`. HLA locus asterisk (e.g., `\"*\"`, `\"B*\"`, `\"DRB1*\"`). allele_2f `character`. Two-field allele designation (e.g., `\"01:01\"`, `\"07:02\"`). serology `character`. Serological antigen number (e.g., `\"1\"`, `\"7\"`).","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_serology.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"WMDA DNA-to-Serology Mapping — deepMatchR_wmda_serology","text":"WMDA nomenclature files IMGT/HLA GitHub repository   (https://github.com/ANHIG/IMGTHLA/tree/Latest/wmda).","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_serology.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"WMDA DNA-to-Serology Mapping — deepMatchR_wmda_serology","text":"mapping prioritizes serology assignments order: Unambiguous assignments Possible assignments Assumed assignments Expert assignments","code":""},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_splits.html","id":null,"dir":"Reference","previous_headings":"","what":"WMDA Broad-to-Split Antigen Relationships — deepMatchR_wmda_splits","title":"WMDA Broad-to-Split Antigen Relationships — deepMatchR_wmda_splits","text":"lookup table mapping broad serological antigens split antigens based WMDA nomenclature. Used internally toSerology resolve_splits = TRUE.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_splits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"WMDA Broad-to-Split Antigen Relationships — deepMatchR_wmda_splits","text":"","code":"data(deepMatchR_wmda_splits)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_splits.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"WMDA Broad-to-Split Antigen Relationships — deepMatchR_wmda_splits","text":"data.table following columns: locus `character`. Serology locus prefix (e.g., `\"\"`, `\"B\"`, `\"DR\"`). broad `character`. Broad antigen number (e.g., `\"2\"`, `\"5\"`). splits `character`. Pipe-separated split antigen numbers (e.g., `\"15|16\"`).","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_splits.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"WMDA Broad-to-Split Antigen Relationships — deepMatchR_wmda_splits","text":"WMDA nomenclature files IMGT/HLA GitHub repository   (https://github.com/ANHIG/IMGTHLA/tree/Latest/wmda).","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepMatchR_wmda_splits.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"WMDA Broad-to-Split Antigen Relationships — deepMatchR_wmda_splits","text":"Common examples broad--split relationships: DR2 -> DR15, DR16 DR5 -> DR11, DR12 B5 -> B51, B52","code":""},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepmatchrEnv.html","id":null,"dir":"Reference","previous_headings":"","what":"Return a Basilisk environment tailored to the current platform — deepmatchrEnv","title":"Return a Basilisk environment tailored to the current platform — deepmatchrEnv","text":"Returns appropriate Basilisk environment MHCnuggets based current operating system. environment used internally predictMHCnuggets Python integration.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepmatchrEnv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return a Basilisk environment tailored to the current platform — deepmatchrEnv","text":"","code":"deepmatchrEnv(platform = c(\"auto\", \"linux\", \"macos\"))"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepmatchrEnv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return a Basilisk environment tailored to the current platform — deepmatchrEnv","text":"platform Character. One \"auto\" (default), \"linux\", \"macos\". \"auto\", platform detected automatically.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepmatchrEnv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return a Basilisk environment tailored to the current platform — deepmatchrEnv","text":"BasiliskEnvironment object configured current platform.","code":""},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/deepmatchrEnv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return a Basilisk environment tailored to the current platform — deepmatchrEnv","text":"","code":"# Get the environment for the current platform env <- deepmatchrEnv() print(class(env)) #> [1] \"BasiliskEnvironment\" #> attr(,\"package\") #> [1] \"basilisk\"  # Explicitly request Linux environment env_linux <- deepmatchrEnv(platform = \"linux\")"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/dot-deriveMismatchedPeptides.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive mismatched peptides from sequence comparison — .deriveMismatchedPeptides","title":"Derive mismatched peptides from sequence comparison — .deriveMismatchedPeptides","text":"Derive mismatched peptides sequence comparison","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/dot-deriveMismatchedPeptides.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive mismatched peptides from sequence comparison — .deriveMismatchedPeptides","text":"","code":".deriveMismatchedPeptides(donor_alleles, recipient_alleles, peptide_length)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/dot-extractAlleles.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract allele names from various input types — .extractAlleles","title":"Extract allele names from various input types — .extractAlleles","text":"Extract allele names various input types","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/dot-extractAlleles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract allele names from various input types — .extractAlleles","text":"","code":".extractAlleles(x)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/dot-getPeptides.html","id":null,"dir":"Reference","previous_headings":"","what":"Get peptides from donor input — .getPeptides","title":"Get peptides from donor input — .getPeptides","text":"Get peptides donor input","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/dot-getPeptides.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get peptides from donor input — .getPeptides","text":"","code":".getPeptides(donor, recipient, peptide_length)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/dot-predictBinding.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict binding using selected backend — .predictBinding","title":"Predict binding using selected backend — .predictBinding","text":"Predict binding using selected backend","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/dot-predictBinding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict binding using selected backend — .predictBinding","text":"","code":".predictBinding(peptides, alleles, backend, backend_path, peptide_length)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/dot-predictBindingMHCnuggets.html","id":null,"dir":"Reference","previous_headings":"","what":"MHCnuggets-based binding prediction — .predictBindingMHCnuggets","title":"MHCnuggets-based binding prediction — .predictBindingMHCnuggets","text":"Uses predictMHCnuggets function deep learning-based binding prediction. MHCnuggets available https://github.com/KarchinLab/mhcnuggets.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/dot-predictBindingMHCnuggets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MHCnuggets-based binding prediction — .predictBindingMHCnuggets","text":"","code":".predictBindingMHCnuggets(peptides, alleles)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/dot-predictBindingNetMHCpan.html","id":null,"dir":"Reference","previous_headings":"","what":"NetMHCpan-based binding prediction — .predictBindingNetMHCpan","title":"NetMHCpan-based binding prediction — .predictBindingNetMHCpan","text":"NetMHCpan-based binding prediction","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/dot-predictBindingNetMHCpan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NetMHCpan-based binding prediction — .predictBindingNetMHCpan","text":"","code":".predictBindingNetMHCpan(peptides, alleles, backend_path)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/dot-predictBindingPWM.html","id":null,"dir":"Reference","previous_headings":"","what":"PWM-based binding prediction (built-in) — .predictBindingPWM","title":"PWM-based binding prediction (built-in) — .predictBindingPWM","text":"PWM-based binding prediction (built-)","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/dot-predictBindingPWM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PWM-based binding prediction (built-in) — .predictBindingPWM","text":"","code":".predictBindingPWM(peptides, alleles)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/getAlleleSequence.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Sequence for an HLA Allele — getAlleleSequence","title":"Get Sequence for an HLA Allele — getAlleleSequence","text":"Improved version session-level caching avoid redundant API calls. Uses memoise automatic caching. Supports nucleotide protein sequences.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/getAlleleSequence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Sequence for an HLA Allele — getAlleleSequence","text":"","code":"getAlleleSequence(   allele_name,   type = c(\"PROT\", \"NUC\"),   use_cache = TRUE,   cache_dir = NULL )"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/getAlleleSequence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Sequence for an HLA Allele — getAlleleSequence","text":"allele_name character string representing HLA allele name type type sequence retrieve. Either \"NUC\" nucleotide \"PROT\" protein sequences (default \"PROT\") use_cache Logical, whether use caching (default TRUE) cache_dir Optional directory persistent cache","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/getAlleleSequence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Sequence for an HLA Allele — getAlleleSequence","text":"character string representing sequence (amino acid nucleotide)","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/getAlleleSequence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Sequence for an HLA Allele — getAlleleSequence","text":"","code":"# \\donttest{ # Collecting A*02:01 Protein Sequence (requires internet): seq <- getAlleleSequence(\"A*02:01\") nchar(seq)  # Length of sequence #> [1] 365  # Collecting A*02:01 Nucleotide Sequence: seq_nuc <- getAlleleSequence(\"A*02:01\", type = \"NUC\")  # Get sequence for HLA-B allele seq_b <- getAlleleSequence(\"B*07:02\") # }"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/getSequenceStats.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Sequence Statistics — getSequenceStats","title":"Get Sequence Statistics — getSequenceStats","text":"Analyzes sequences provide statistics length, composition, optionally comparison metrics (reference similarity, pairwise identity), k-mer entropy, data-quality flags.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/getSequenceStats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Sequence Statistics — getSequenceStats","text":"","code":"getSequenceStats(   sequences,   type = c(\"PROT\", \"NUC\"),   ref = NULL,   k = 2L,   ignore_chars = c(\"*\", \"-\", \" \"),   compute_pairs = FALSE,   warn_invalid = TRUE )"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/getSequenceStats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Sequence Statistics — getSequenceStats","text":"sequences Named list (named character vector) sequences (e.g., output batchGetSequences). Names allele IDs. type Type sequences: \"PROT\" (amino acids) \"NUC\" (nucleotides). ref Optional reference comparison; either *name* one sequence `sequences` raw sequence string `type`. k Integer k k-mer Shannon entropy (default 2). ignore_chars Characters ignore computing counts/identity (default c(\"*\", \"-\", \" \")). Useful protein stop symbols gaps. compute_pairs Logical; TRUE, also compute pairwise percent identity matrix (alignment-free, position-wise) return list `stats` `pairwise_identity`. Default FALSE (returns `stats`). warn_invalid Logical; TRUE (default), warn invalid symbols chosen `type` detected.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/getSequenceStats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Sequence Statistics — getSequenceStats","text":"`compute_pairs = FALSE` (default): data.frame per-sequence stats. `compute_pairs = TRUE`: list elements:   - `stats`: per-sequence stats data.frame   - `pairwise_identity`: numeric matrix (0..1) ","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/getSequenceStats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Sequence Statistics — getSequenceStats","text":"","code":"alleles <- c(\"A*01:01\", \"A*02:01\", \"B*07:02\") seqs <- batchGetSequences(alleles) stats <- getSequenceStats(seqs, type = \"PROT\")"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/hlaGeno.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an hla_genotype object — hlaGeno","title":"Create an hla_genotype object — hlaGeno","text":"Creates new `hla_genotype` object data frame HLA calls. object list containing genotype data record loci present.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/hlaGeno.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an hla_genotype object — hlaGeno","text":"","code":"hlaGeno(df)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/hlaGeno.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an hla_genotype object — hlaGeno","text":"df data frame rows individuals columns represent HLA alleles (e.g., A_1, A_2, B_1, B_2, ...).","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/hlaGeno.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an hla_genotype object — hlaGeno","text":"object class `hla_genotype`.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/hlaGeno.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an hla_genotype object — hlaGeno","text":"","code":"# Create a genotype from a data frame recipient <- data.frame(   A_1 = \"A*01:01\", A_2 = \"A*02:01\",   B_1 = \"B*07:02\", B_2 = \"B*08:01\" ) geno <- hlaGeno(recipient) print(geno) #> HLA Genotype Data #> ----------------- #> Loci present: A, B  #> Number of samples: 1  #>  #>       A_1     A_2     B_1     B_2 #> 1 A*01:01 A*02:01 B*07:02 B*08:01  # Access components geno$locus_present #> [1] \"A\" \"B\" geno$data #>       A_1     A_2     B_1     B_2 #> 1 A*01:01 A*02:01 B*07:02 B*08:01"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/plotAntibodies.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Antibody Data with Optional Antigen-Level Table or Time-Series Trend — plotAntibodies","title":"Plot Antibody Data with Optional Antigen-Level Table or Time-Series Trend — plotAntibodies","text":"function generates bar plot SAB (Single Antigen Beads) PRA (Panel-Reactive Antibody) results provided data frame file path. can also plot MFI values time.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/plotAntibodies.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Antibody Data with Optional Antigen-Level Table or Time-Series Trend — plotAntibodies","text":"","code":"plotAntibodies(   result_file,   type = \"SAB\",   class = \"I\",   plot_trend = FALSE,   bead_cutoffs = NULL,   highlight_threshold = 2000,   vline_dates = NULL,   add_table = TRUE,   x_text_angle = 90,   palette = \"spectral\",   highlight_antigen = NULL,   ... )  plotSAB(..., type = \"SAB\")  plotPRA(..., type = \"PRA\")"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/plotAntibodies.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Antibody Data with Optional Antigen-Level Table or Time-Series Trend — plotAntibodies","text":"result_file data frame, list data frames (trend plot), character string specifying path file CSV, XLS, XLSX format. type Character. type assay, either \"SAB\" \"PRA\". Defaults \"SAB\". class Character. PRA plots, class assay, either \"\" \"II\". Defaults \"\". plot_trend Logical. TRUE, time-series plot generated. Defaults FALSE. bead_cutoffs Numeric vector. Cutoff values categorizing MFI values. Defaults `c(2000, 1000, 500, 250)` SAB `c(1500, 1000, 500, 250)` PRA. highlight_threshold Numeric. MFI threshold highlighting alleles trend plot. Defaults 2000. vline_dates Vector dates. Dates draw vertical lines trend plot. add_table Logical. Whether add antigen-level information table bottom bar plot. Defaults TRUE. x_text_angle Numeric. Angle antigen/allele text table. Defaults 90. palette Character. color palette name. Defaults \"spectral\". highlight_antigen Character vector. Optional antigen(s) highlight. ... Additional arguments passed ggplot theme.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/plotAntibodies.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Antibody Data with Optional Antigen-Level Table or Time-Series Trend — plotAntibodies","text":"`ggplot` object.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/plotAntibodies.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Antibody Data with Optional Antigen-Level Table or Time-Series Trend — plotAntibodies","text":"","code":"# Plot SAB Class I data plotAntibodies(deepMatchR_example[[1]], type = \"SAB\")   # Plot without table plotAntibodies(deepMatchR_example[[1]], type = \"SAB\", add_table = FALSE)   # Plot SAB Class II data plotAntibodies(deepMatchR_example[[2]], type = \"SAB\")"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/plotEplets.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Eplet Results from SPI Assay — plotEplets","title":"Plot Eplet Results from SPI Assay — plotEplets","text":"function reads SAB (single antigen bead) results (either data frame file path CSV/XLS/XLSX file), processes data quantify eplet-specific positivity based specified MFI cutoff, generates one three plot types: treemap, bar plot, AUC plot. eplet annotations joined internal database, resulting plot colored evidence level.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/plotEplets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Eplet Results from SPI Assay — plotEplets","text":"","code":"plotEplets(   result_file,   cutoff = 2000,   evidence_level = c(\"A1\", \"A2\"),   group_by = \"eplet\",   eplet_filter = 3,   percPos_filter = 0.4,   plot_type = c(\"treemap\", \"bar\", \"AUC\"),   cut_min = 250,   cut_max = 10000,   cut_step = 250,   top_eplets = 10,   palette = \"spectral\",   ... )"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/plotEplets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Eplet Results from SPI Assay — plotEplets","text":"result_file data frame containing SAB results character string specifying path SAB file CSV, XLS, XLSX format. cutoff Numeric. Threshold MFI separate positive negative beads. Default 2000. evidence_level Character vector indicating antibody reactivity levels keep. Defaults c(\"A1\", \"A2\"), represent antibody-confirmed eplets. acceptable levels include \"B\", \"D\", NULL apply filter. group_by character string indicating coloring grouping plot, default `eplet`. options include `loci` `evidence_level`. eplet_filter Integer. (used plot_type = \"AUC\") Specifying minimum number times eplet must appear assay calculating AUC. Defaults `3`. percPos_filter Numeric value. (used plot_type = \"AUC\") Value 0 1 specifying minimum relative proportion positive beads (per eplet) include final summary. Eplets proportion threshold excluded. Defaults 0.4. plot_type Character. Type plot generate. Must one \"treemap\", \"bar\", \"AUC\". Defaults \"treemap\". cut_min Integer. (used plot_type = \"AUC\") minimum MFI cutoff value. Defaults 250. cut_max Integer. (used plot_type = \"AUC\") maximum MFI cutoff value. Defaults 10000. cut_step Integer. (used plot_type = \"AUC\") increment step minimum maximum MFI cutoff values. Defaults 250. top_eplets Integer. maximum number top eplets display bar AUC plot. Defaults 10. palette Character. color palette name (hcl.pals) custom palette function use plot. Defaults \"spectral\". ... Additional arguments passed ggplot theme","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/plotEplets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Eplet Results from SPI Assay — plotEplets","text":"ggplot object visualizing eplet counts (AUC values) according   specified parameters.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/plotEplets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Eplet Results from SPI Assay — plotEplets","text":"","code":"# Using a data frame: plotEplets(deepMatchR_example[[1]],             cutoff = 2000,             evidence_level = c(\"A1\", \"A2\", \"B\"),            percPos_filter = 0.4,             plot_type = \"treemap\")"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/predictMHCnuggets.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict peptide–MHC binding with mhcnuggets — predictMHCnuggets","title":"Predict peptide–MHC binding with mhcnuggets — predictMHCnuggets","text":"Calls Python's mhcnuggets.src.predict.predict inside basilisk-managed environment score peptides given MHC allele. default predictions written Python temporary CSV read back R, avoids Python stdout capture typically faster robust.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/predictMHCnuggets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict peptide–MHC binding with mhcnuggets — predictMHCnuggets","text":"","code":"predictMHCnuggets(   peptides,   allele,   mhc_class = \"I\",   output_path = NULL,   normalize_allele = TRUE,   model = \"lstm\",   mass_spec = FALSE,   ic50_threshold = 500L,   max_ic50 = 50000L,   embed_peptides = FALSE,   binary_preds = FALSE,   ba_models = FALSE,   rank_output = FALSE,   hla_env = deepmatchrEnv() )"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/predictMHCnuggets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict peptide–MHC binding with mhcnuggets — predictMHCnuggets","text":"peptides Character vector peptide sequences (one per peptide). allele MHC allele string. normalize_allele=TRUE, common forms like \"A0201\" normalized \"HLA-A02:01\" class \"HLA-DRB101:01\" class II. mhc_class Either \"\" \"II\" (default \"\"). output_path Optional file path Python write CSV results. NULL (default), secure temporary file used deleted exit. normalize_allele Logical; normalize allele mhcnuggets' expected format (default TRUE). Set FALSE already use exact mhcnuggets allele names. model Model architecture string (default \"lstm\"). mass_spec Logical; use MS-calibrated settings (default FALSE). ic50_threshold Numeric IC50 threshold (nM) binding calls (default 500). max_ic50 Numeric max IC50 (nM) capping (default 50000). embed_peptides Logical; use embedding (default FALSE). binary_preds Logical; request binary predictions (default FALSE). ba_models Logical; force binding affinity models (default FALSE). rank_output Logical; request rank output (default FALSE). hla_env basilisk environment object contains Python + mhcnuggets (e.g., hlaFerretEnv).","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/predictMHCnuggets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict peptide–MHC binding with mhcnuggets — predictMHCnuggets","text":"data.frame. Columns depend options: Default: peptide, ic50 binary_preds=TRUE: peptide, binary_pred (plus ic50 emitted model) rank_output=TRUE: includes rank (0–1 percentile)","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/predictMHCnuggets.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict peptide–MHC binding with mhcnuggets — predictMHCnuggets","text":"wrapper exposes mhcnuggets' arguments advanced users can fully control model choice, thresholds, output format. also applies small, session-local patch older mhcnuggets code calls keras.optimizers.Adam(lr=...) works newer Keras (maps lr learning_rate).","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/predictMHCnuggets.html","id":"license-and-citation","dir":"Reference","previous_headings":"","what":"License and Citation","title":"Predict peptide–MHC binding with mhcnuggets — predictMHCnuggets","text":"mhcnuggets licensed GNU General Public License v3.0. use MHCnuggets work, please cite: Shao, B., et al. (2020). MHCnuggets: deep learning method peptide-MHC binding prediction. bioRxiv. GitHub: https://github.com/KarchinLab/mhcnuggets","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/predictMHCnuggets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict peptide–MHC binding with mhcnuggets — predictMHCnuggets","text":"","code":"res <- predictMHCnuggets(   peptides = c(\"SIINFEKL\",\"LLFGYPVYV\"),   allele   = \"A*02:01\",   mhc_class = \"I\",   rank_output = TRUE ) #> Installing pyenv ... #> Done! pyenv has been installed to '/home/runner/.local/share/r-reticulate/pyenv/bin/pyenv'. #> Using Python: /home/runner/.pyenv/versions/3.10.19/bin/python3.10 #> Creating virtual environment '/home/runner/.cache/R/basilisk/1.22.0/deepMatchR/0.99.0/deepmatchrEnv_v2' ...  #> + /home/runner/.pyenv/versions/3.10.19/bin/python3.10 -m venv /home/runner/.cache/R/basilisk/1.22.0/deepMatchR/0.99.0/deepmatchrEnv_v2 #> Done! #> Installing packages: pip, wheel, setuptools #> + /home/runner/.cache/R/basilisk/1.22.0/deepMatchR/0.99.0/deepmatchrEnv_v2/bin/python -m pip install --upgrade pip wheel setuptools #> Installing packages: 'mhcnuggets==2.4.1', 'tensorflow==2.19.1' #> + /home/runner/.cache/R/basilisk/1.22.0/deepMatchR/0.99.0/deepmatchrEnv_v2/bin/python -m pip install --upgrade --no-user 'mhcnuggets==2.4.1' 'tensorflow==2.19.1' #> Virtual environment '/home/runner/.cache/R/basilisk/1.22.0/deepMatchR/0.99.0/deepmatchrEnv_v2' successfully created. head(res) #>     peptide    ic50 #> 1  SIINFEKL 5600.06 #> 2 LLFGYPVYV  535.92"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/print.hla_genotype.html","id":null,"dir":"Reference","previous_headings":"","what":"Print an hla_genotype object — print.hla_genotype","title":"Print an hla_genotype object — print.hla_genotype","text":"Print hla_genotype object","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/print.hla_genotype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print an hla_genotype object — print.hla_genotype","text":"","code":"# S3 method for class 'hla_genotype' print(x, ...)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/print.hla_genotype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print an hla_genotype object — print.hla_genotype","text":"x object class `hla_genotype`. ... Additional arguments (used).","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/print.hla_genotype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print an hla_genotype object — print.hla_genotype","text":"Invisibly returns original object.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/print.hla_genotype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print an hla_genotype object — print.hla_genotype","text":"","code":"df <- data.frame(A_1 = \"A*01:01\", B_1 = \"B*07:02\") geno <- hlaGeno(df) print(geno) #> HLA Genotype Data #> ----------------- #> Loci present: A, B  #> Number of samples: 1  #>  #>       A_1     B_1 #> 1 A*01:01 B*07:02"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/quantifyEpletMismatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantify Eplet Mismatches Between Two Alleles — quantifyEpletMismatch","title":"Quantify Eplet Mismatches Between Two Alleles — quantifyEpletMismatch","text":"Counts number **eplet mismatches** two HLA alleles, using internal `deepMatchR_eplets` dataset. Supports filtering **evidence** (e.g., A1/A2), **exposition** (e.g., \"High\", \"Moderate\"), **reactivity** (e.g., IgG/IgM labels present table).","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/quantifyEpletMismatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantify Eplet Mismatches Between Two Alleles — quantifyEpletMismatch","text":"","code":"quantifyEpletMismatch(   allele1,   allele2,   evidence_level = c(\"A1\", \"A2\"),   exposition_filter = NULL,   reactivity_filter = NULL )"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/quantifyEpletMismatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantify Eplet Mismatches Between Two Alleles — quantifyEpletMismatch","text":"allele1, allele2 Character scalars, e.g. `\"*01:01\"`, `\"*02:01\"`. evidence_level Character vector evidence levels include (default `c(\"A1\",\"A2\")`). Use `NULL` evidence filter. exposition_filter Character vector exposition classes include (e.g., `c(\"High\",\"Moderate\")`). Default `NULL` = exposition filter. reactivity_filter Character vector reactivity classes include (dataset-dependent). Default `NULL` = reactivity filter.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/quantifyEpletMismatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantify Eplet Mismatches Between Two Alleles — quantifyEpletMismatch","text":"Integer: size **symmetric difference** eplet sets   two alleles filters (.e., eplets present one allele ).","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/quantifyEpletMismatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantify Eplet Mismatches Between Two Alleles — quantifyEpletMismatch","text":"","code":"# Count eplet mismatches between two alleles quantifyEpletMismatch(\"A*01:01\", \"A*02:01\") #> [1] 13  # With evidence level filter quantifyEpletMismatch(\"A*01:01\", \"A*02:01\", evidence_level = \"A1\") #> [1] 8  # Same allele returns 0 quantifyEpletMismatch(\"A*01:01\", \"A*01:01\") #> [1] 0"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/quantifyMismatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantify Amino Acid Mismatches With Charge/Polarity Awareness (base R) — quantifyMismatch","title":"Quantify Amino Acid Mismatches With Charge/Polarity Awareness (base R) — quantifyMismatch","text":"Compares two amino acid sequences (length) quantifies mismatches. mismatch annotated whether changes residue charge /polarity. Users can filter mismatches count based properties.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/quantifyMismatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantify Amino Acid Mismatches With Charge/Polarity Awareness (base R) — quantifyMismatch","text":"","code":"quantifyMismatch(   sequence1,   sequence2,   filter_charge = NULL,   filter_polarity = NULL,   return = c(\"count\", \"detail\"),   na_action = c(\"exclude\", \"error\", \"count\"),   type = c(\"global\", \"local\", \"overlap\"),   substitutionMatrix = \"BLOSUM80\",   gapOpening = 10,   gapExtension = 1,   count_gaps = TRUE )"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/quantifyMismatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantify Amino Acid Mismatches With Charge/Polarity Awareness (base R) — quantifyMismatch","text":"sequence1, sequence2 Character strings equal length (AAs). filter_charge NULL/TRUE/FALSE - `NULL` (default): ignore charge filtering (.e., filter). - `TRUE`: count mismatches change charge. - `FALSE`: count mismatches ** change charge. filter_polarity NULL/TRUE/FALSE. - `NULL` (default): ignore polarity filtering. - `TRUE`: count mismatches change polarity. - `FALSE`: count mismatches ** change polarity. return return: one \"count\" (default) \"detail\" na_action One \"exclude\" (default), \"error\", \"count\". Controls handling unknown residues (e.g., X, *, -). type Character string. type alignment perform. Defaults `\"global\"` allows `\"local\"` `\"overlap\"`-based alignments sequences. substitutionMatrix Character string numeric matrix. Substitution scoring matrix used sequence alignment. Defaults `\"BLOSUM80\"`, provides conservative amino acid similarity scheme suitable closely related protein sequences. gapOpening Numeric scalar. Penalty score applied initiating new gap alignment. Higher values discourage insertion/deletion events yield contiguous alignments. Default `10`. gapExtension Numeric scalar. Penalty score applied extending existing gap. Smaller values permit longer continuous gaps, larger values favor shorter gaps. Default `1`. count_gaps Logical (default `TRUE`). `TRUE`, positions one sequence contains gap (`-`) contains amino acid treated mismatches included mismatch count.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/quantifyMismatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantify Amino Acid Mismatches With Charge/Polarity Awareness (base R) — quantifyMismatch","text":"- return = \"count\": integer (count filters). - return = \"detail\": table columns:   position, ref, alt, is_mismatch, charge_ref, charge_alt, charge_change,   polarity_ref, polarity_alt, polarity_change, counted.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/quantifyMismatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantify Amino Acid Mismatches With Charge/Polarity Awareness (base R) — quantifyMismatch","text":"","code":"seq1 <- \"YFAMYGEKVAHTHVDTLYVRYHY\" seq2 <- \"YFDMYGEKVAHTHVDTLYVRFHY\"  # Numerical quantification of mismatches quantifyMismatch(seq1, seq2) #> [1] 2  # Count only mismatches that change charge quantifyMismatch(seq1, seq2, filter_charge = TRUE) #> [1] 1  # Count only mismatches that change polarity quantifyMismatch(seq1, seq2, filter_polarity = TRUE) #> [1] 2  # Count mismatches that change charge AND polarity quantifyMismatch(seq1, seq2, filter_charge = TRUE, filter_polarity = TRUE) #> [1] 1"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/toSerology.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert HLA Alleles to Serological Equivalents — toSerology","title":"Convert HLA Alleles to Serological Equivalents — toSerology","text":"Converts HLA alleles IMGT/HLA nomenclature (e.g., \"*01:01\") serological equivalents (e.g., \"A1\") using WMDA standard nomenclature.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/toSerology.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert HLA Alleles to Serological Equivalents — toSerology","text":"","code":"toSerology(   x,   locus = NULL,   resolve_splits = TRUE,   return = c(\"serology\", \"genotype\", \"data.frame\"),   na_action = c(\"NA\", \"warn\", \"error\") )"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/toSerology.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert HLA Alleles to Serological Equivalents — toSerology","text":"x Character vector HLA alleles hla_genotype object. locus Optional character. Override locus detection ambiguous cases. resolve_splits Logical. TRUE (default), attempts infer split antigens broad antigens (e.g., DR2 -> DR15 DR16 based allele). return Character. Output format: \"serology\" (default): Returns character vector serology strings \"genotype\": Returns hla_genotype *_ser_* columns added \"data.frame\": Returns data.frame allele, locus, serology columns na_action Character. handle alleles without serology mapping: \"NA\" (default): Return NA unknown alleles \"warn\": Return NA issue warning \"error\": Stop error","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/toSerology.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert HLA Alleles to Serological Equivalents — toSerology","text":"Depends return parameter. See .","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/toSerology.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert HLA Alleles to Serological Equivalents — toSerology","text":"function uses WMDA (World Marrow Donor Association) nomenclature files map HLA alleles serological equivalents. mapping considers: Unambiguous assignments (highest priority) Possible assignments Assumed assignments Expert assignments resolve_splits = TRUE, broad antigens like DR2 resolved split antigens (DR15 DR16) based specific allele. P-group notation (e.g., \"*01:01P\") automatically resolved reference allele.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/toSerology.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert HLA Alleles to Serological Equivalents — toSerology","text":"","code":"# Single allele conversion toSerology(\"A*01:01\") #> [1] \"A1\"  # Vector of alleles toSerology(c(\"A*01:01\", \"B*07:02\", \"DRB1*03:01\")) #> [1] \"A1\"   \"B7\"   \"DR17\"  # Get detailed data.frame toSerology(c(\"A*01:01\", \"B*07:02\"), return = \"data.frame\") #>    allele locus allele_2f serology serology_full #> 1 A*01:01     A     01:01        1            A1 #> 2 B*07:02     B     07:02        7            B7  # With hla_genotype object geno <- hlaGeno(data.frame(   A_1 = \"A*01:01\", A_2 = \"A*02:01\",   B_1 = \"B*07:02\", B_2 = \"B*08:01\",   stringsAsFactors = FALSE )) toSerology(geno, return = \"serology\") #> A*01:01 A*02:01 B*07:02 B*08:01  #>    \"A1\"    \"A2\"    \"B7\"    \"B8\"  toSerology(geno, return = \"genotype\") #> HLA Genotype Data #> ----------------- #> Loci present: A, B  #> Number of samples: 1  #>  #>       A_1     A_2     B_1     B_2 A_ser_1 A_ser_2 B_ser_1 B_ser_2 #> 1 A*01:01 A*02:01 B*07:02 B*08:01      A1      A2      B7      B8"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/updateWmdaData.html","id":null,"dir":"Reference","previous_headings":"","what":"Update WMDA Nomenclature Data — updateWmdaData","title":"Update WMDA Nomenclature Data — updateWmdaData","text":"Downloads fresh WMDA nomenclature data IMGT/HLA GitHub repository caches locally use toSerology.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/updateWmdaData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update WMDA Nomenclature Data — updateWmdaData","text":"","code":"updateWmdaData(   version = \"Latest\",   cache_dir = NULL,   force = FALSE,   verbose = TRUE )"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/updateWmdaData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update WMDA Nomenclature Data — updateWmdaData","text":"version Character. IMGT/HLA version download. Default \"Latest\" recent release. Can also specific version tag (e.g., \"3.54.0\"). cache_dir Character. Directory store cached data. NULL (default), uses package's default cache location. force Logical. TRUE, re-download even cached data exists. verbose Logical. TRUE (default), print progress messages.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/updateWmdaData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update WMDA Nomenclature Data — updateWmdaData","text":"Invisibly returns path cache directory.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/updateWmdaData.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Update WMDA Nomenclature Data — updateWmdaData","text":"WMDA nomenclature files downloaded : https://github.com/ANHIG/IMGTHLA Downloaded files: rel_dna_ser.txt: DNA serology mappings rel_ser_ser.txt: Broad split relationships hla_nom_p.txt: P-group definitions cache stored single RDS file fast loading. clear cache revert bundled data, delete cache directory set environment variable DEEPMATCHR_CACHE_DIR new location.","code":""},{"path":[]},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/updateWmdaData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update WMDA Nomenclature Data — updateWmdaData","text":"","code":"# Show default cache directory (does not download) cache_dir <- file.path(tempdir(), \"wmda_test\") print(cache_dir) #> [1] \"/tmp/RtmpVcGTYA/wmda_test\"  # \\donttest{ # Update to latest WMDA data (requires internet) updateWmdaData() #> Downloading WMDA data (version: Latest)... #>   Downloading rel_dna_ser.txt... #>   Downloading rel_ser_ser.txt... #>   Downloading hla_nom_p.txt... #>   Saving to cache... #> Done! Cached 27260 serology mappings, 23 split mappings, 18757 P-groups #> Cache location: ~/.cache/deepMatchR  # Force re-download even if cache exists updateWmdaData(force = TRUE) #> Downloading WMDA data (version: Latest)... #>   Downloading rel_dna_ser.txt... #>   Downloading rel_ser_ser.txt... #>   Downloading hla_nom_p.txt... #>   Saving to cache... #> Done! Cached 27260 serology mappings, 23 split mappings, 18757 P-groups #> Cache location: ~/.cache/deepMatchR # }"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/validateHlaGeno.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate an hla_genotype object — validateHlaGeno","title":"Validate an hla_genotype object — validateHlaGeno","text":"Validate hla_genotype object","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/validateHlaGeno.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate an hla_genotype object — validateHlaGeno","text":"","code":"validateHlaGeno(x)"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/validateHlaGeno.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate an hla_genotype object — validateHlaGeno","text":"x object validate.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/validateHlaGeno.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate an hla_genotype object — validateHlaGeno","text":"`TRUE` object valid `hla_genotype` object, otherwise   throws error.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/visualizePeptideBinding.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize Cross-Locus Peptide Binding Results — visualizePeptideBinding","title":"Visualize Cross-Locus Peptide Binding Results — visualizePeptideBinding","text":"Creates visualizations peptide binding predictions across loci. function designed advanced cross-locus analysis peptides multiple donor alleles tested multiple recipient alleles.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/visualizePeptideBinding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize Cross-Locus Peptide Binding Results — visualizePeptideBinding","text":"","code":"visualizePeptideBinding(   binding_results,   plot_type = c(\"heatmap\", \"bar_by_recipient\", \"bar_by_donor\", \"scatter\"),   palette = \"spectral\",   ... )"},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/visualizePeptideBinding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize Cross-Locus Peptide Binding Results — visualizePeptideBinding","text":"binding_results list containing `all_predictions` data.frame columns: `donor_allele`, `recipient_allele`, `binding` (logical), `recipient_locus`, `mhc_class`, `donor_locus`, optionally `ic50`. plot_type Type plot: \"heatmap\", \"bar_by_recipient\", \"bar_by_donor\", \"scatter\" palette Character. color palette name. Defaults \"spectral\". ... Additional arguments passed ggplot theme.","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/visualizePeptideBinding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize Cross-Locus Peptide Binding Results — visualizePeptideBinding","text":"ggplot object","code":""},{"path":"https://www.borch.dev/uploads/deepMatchR/reference/visualizePeptideBinding.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize Cross-Locus Peptide Binding Results — visualizePeptideBinding","text":"","code":"# Create example binding results data structure binding_results <- list(   all_predictions = data.frame(     donor_allele = rep(c(\"A*01:01\", \"A*24:02\"), each = 4),     recipient_allele = rep(c(\"A*02:01\", \"A*03:01\"), 4),     recipient_locus = \"A\",     donor_locus = \"A\",     mhc_class = \"I\",     binding = c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE),     ic50 = c(100, 6000, 250, 150, 8000, 300, 7500, 9000)   ) )  # Create heatmap visualization p <- visualizePeptideBinding(binding_results, plot_type = \"heatmap\") print(p)   # Create bar plot by recipient p2 <- visualizePeptideBinding(binding_results, plot_type = \"bar_by_recipient\") print(p2)"}]
